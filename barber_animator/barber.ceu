#include "sdl_animator.ceu"

native do
  #include <assert.h>

  int random_plusminus(int center, int plusminus) {
    return center - plusminus + rand() % (plusminus * 2);
  }
  
  typedef struct {
    int count_allocated;
    int allocated[10];
  } Storage;

  void storage_set_empty(Storage* f) {
    int i;

    f->count_allocated = 0;
    for (i = 0; i < 10; i += 1) {
      f->allocated[i] = 0;
    }
  }

  int storage_count(Storage* f) {
    return f->count_allocated;
  }

  int storage_full(Storage* f) {
    return f->count_allocated >= 10;
  }

  int storage_empty(Storage* f) {
    return f->count_allocated == 0;
  }

  int storage_enter(Storage* f) {
    int i;
    assert(!storage_full(f));
    for (i = 0; i < 10; i += 1) {
      if (!f->allocated[i]) {
        f->allocated[i] = 1;
        f->count_allocated += 1;
        return i;
      }
    }
    assert(0);
  }

  void storage_leave(Storage* f, int which) {
    assert(f->count_allocated > 0);
    assert(f->allocated[which]);
    f->count_allocated -= 1;
    f->allocated[which] = 0;
  }
end

native @nohold _assert();

native _random_plusminus();

native @plain _Storage;
native @nohold _storage_set_empty();
native @nohold _storage_full();
native @nohold _storage_empty();
native @nohold _storage_count();
native @nohold _storage_enter();
native @nohold _storage_leave();

class Barber with
  var _Storage chairs;
  var _Storage barbers;
  event void next;
do
  _storage_set_empty(&chairs);
  _storage_set_empty(&barbers);
end

class Customer with
  var Barber& barber;
  var Kind& kind;
  var _SDL_Renderer[] ren;
do
  if _storage_full(&barber.chairs) then
    // balk
    var Object* rep = spawn Object with
      this.kind = kind;
      this.ren = ren;
      this.x = 10;
      this.y = 10;
      this.destx = 10;
      this.desty = 580;
    end;
    _assert(rep);
    watching rep do
      await 2s;
      emit (*rep).destroy;
    end
  else/if not _storage_full(&barber.barbers) and _storage_empty(&barber.chairs) then
    // get a haircut without a wait
    var int which_barber = _storage_enter(&barber.barbers);
    var Object* rep = spawn Object with
      this.kind = kind;
      this.ren = ren;
      this.x = 10;
      this.y = 10;
      this.destx = 400;
      this.desty = 10;
    end;
    _assert(rep);
    watching rep do
      await 2s;
      _assert((*rep).x == 400);
      _assert((*rep).y == 10);
      emit (*rep).move => (400 + 25 * which_barber, 300);
      await (_random_plusminus(30000, 6000))ms;
      _storage_leave(&barber.barbers, which_barber);
      emit barber.next;
      _assert((*rep).x == 400 + 25 * which_barber);
      _assert((*rep).y == 300);
      emit (*rep).move => (10, 580);
      await 2s;
      emit (*rep).destroy;
    end
  else
    // wait for a haircut
    var int which_seat = _storage_enter(&barber.chairs);
    var int ahead = _storage_count(&barber.chairs);
    var Object* rep = spawn Object with
      this.kind = kind;
      this.ren = ren;
      this.x = 10;
      this.y = 10;
      this.destx = 400;
      this.desty = 10;
    end;
    watching rep do
      par/or do
        loop i in ahead do
           await barber.next;
        end
        _assert(not _storage_full(&barber.barbers));
      with
        await 2s;
        (*rep).x = 400;
        (*rep).y = 10;
        emit (*rep).move => (780, 10+25*which_seat);
        await FOREVER;
      end
      _storage_leave(&barber.chairs, which_seat);
      var int which_barber = _storage_enter(&barber.barbers);
      emit (*rep).move => (400 + 25 * which_barber, 300);
      await (_random_plusminus(30000, 6000))ms;
      _storage_leave(&barber.barbers, which_barber);
      emit barber.next;
      _assert((*rep).x == 400 + 25 * which_barber);
      _assert((*rep).y == 300);
      emit (*rep).move => (10, 580);
      await 2s;
      emit (*rep).destroy;
    end
  end
end


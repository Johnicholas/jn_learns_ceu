#include "sdl_animator.ceu"

native do
  #include <assert.h>

  int random_plusminus(int center, int plusminus) {
    return center - plusminus + rand() % (plusminus * 2);
  }
end

native @nohold _assert();

#define SYNC(r) \
  if r.waiting then r.waiting = false; emit r.ready; else r.waiting = true; await r.ready; end

class BarberCustomerRendesvous with
  var Barber& barber;
  var int x;
  var int y;
  function (void)=>bool got_accepted;
  var bool waiting;
  event void ready;
  event void over;
  function (Customer&)=>bool volunteer;
do
  var bool accepted = false;

  function (void)=>bool was_accepted do
    return accepted;
  end

  function (Customer& c)=>bool volunteer do
    if accepted then
      return false;
    else
      accepted = true;
      return true;
    end
  end
end

class CustomerBarberRendesvous with
  var Customer& customer;
  function (Barber&, int, int)=>bool volunteer;
  var bool waiting;
  event void ready;
  event void over;
  function (void)=>bool was_accepted;
  var int x = 50;
  var int y = 50;
do
  var bool accepted = false;

  function (Barber& b, int x, int y)=>bool volunteer do
    if accepted then
      return false;
    else
      accepted = true;
      this.x = x;
      this.y = y;
      return true;
    end
  end

  function (void)=>bool was_accepted do
    return accepted;
  end
end

class BarberQueue with
  var int waiting = 0;
  // sent by servers requesting the next client
  event BarberCustomerRendesvous* next_client;
  // sent by clients requesting the next server
  event CustomerBarberRendesvous* next_server;
do
  // nothing
end

class Barber with
  var Kind& kind;
  var _SDL_Renderer[] ren;
  var int id;
  var BarberQueue& customers;
do
  var Object rep with
    this.kind = kind;
    this.ren = ren;
    this.x = 400+25*id;
    this.y = 300;
    this.destx = 400+25*id;
    this.desty = 300;
  end;

  loop do
    await 1ms; // TODO: necessary?
    // try to get a client
    var BarberCustomerRendesvous r with
      this.barber = outer;
      this.x = rep.x;
      this.y = rep.y;
    end;
    emit customers.next_client => &r;
    if r.got_accepted() then
      SYNC(r);
      // step forward to meet the client
      var int count = 0;
      emit rep.go_move => (&count, rep.x, 290);
      _assert(count == 1);
      await rep.ok_moved;
      await (_random_plusminus(30000, 6000))ms;
      emit r.over;
    else
      // when a client asks for a server, volunteer self
      var CustomerBarberRendesvous[] rptr = null;
      loop do
        rptr = await customers.next_server;
        if rptr:volunteer(this, rep.x, 275) then
          break;
        end
      end
      SYNC((*rptr));
      // step forward to meet the client
      var int count = 0;
      emit rep.go_move => (&count, rep.x, 290);
      _assert(count == 1);
      await rep.ok_moved;
      await (_random_plusminus(30000, 6000))ms;
      emit rptr:over;
    end

    // step back and clean up the station
    var int count = 0;
    emit rep.go_move => (&count, rep.x, 300);
    _assert(count == 1);
    await rep.ok_moved;
  end
end

class Customer with
  var BarberQueue& barbers;
  // var Queue& chairs;
  var Kind& kind;
  var _SDL_Renderer[] ren;
  var int id;
do
  // enter stage left
  var Object rep with
    this.kind = kind;
    this.ren = ren;
    this.x = 10;
    this.y = 10;
    this.destx = 400;
    this.desty = 10;
  end;
  await rep.ok_moved;
  await 1ms; // TODO: necessary?
  // try to get a barber
  var CustomerBarberRendesvous r with
    this.customer = outer;
  end;
  emit barbers.next_server => &r;
  if r.was_accepted() then
    // go to the barber
    var int count = 0;
    emit rep.go_move => (&count, r.x, r.y);
    _assert(count == 1);
    await rep.ok_moved;
    SYNC(r);
    await r.over;
  else
    // when a client asks for a server, volunteer self
    var BarberCustomerRendesvous* rptr = null;
    loop do
      rptr = await barbers.next_client;
      if rptr:volunteer(this, rep.x, 275) then
        break;
      end
    end
    var int count = 0;
    emit rep.go_move => (&count, r.x, r.y);
    _assert(count == 1);
    await rep.ok_moved;
    SYNC((*rptr));
    await rptr:over;
  end

  // leave
  await 1ms; // TODO: necessary?
  var int count = 0;
  emit rep.go_move => (&count, 10, 580);
  _assert(count == 1);
  await rep.ok_moved;
end


#include "sdl_animator.ceu"

native do
  #include <assert.h>

  int random_plusminus(int center, int plusminus) {
    return center - plusminus + rand() % (plusminus * 2);
  }

  typedef struct {
    int total_pushed;
    int total_popped;
    int buffer[1024]; // 1024 is basically infinity
  } Queue;

  void set_empty_queue(Queue* q) {
    int i;

    q->total_pushed = 0;
    q->total_popped = 0;
    for (i = 0; i < 1024; i += 1) {
      q->buffer[i] = 0;
    }
  }

  int empty(Queue* q) {
    return q->total_pushed == q->total_popped;
  }

  void push(Queue* q, int value) {
    q->buffer[q->total_pushed++] = value;
  }

  int pop(Queue* q) {
    return q->buffer[q->total_popped++];
  }

  typedef struct {
    int count_allocated;
    int allocated[10];
  } Storage;

  void set_empty_storage(Storage* f) {
    int i;

    f->count_allocated = 0;
    for (i = 0; i < 10; i += 1) {
      f->allocated[i] = 0;
    }
  }

  int full(Storage* f) {
    return f->count_allocated >= 10;
  }

  int enter(Storage* f) {
    int i;
    assert(!full(f));
    for (i = 0; i < 10; i += 1) {
      if (!f->allocated[i]) {
        f->allocated[i] = 1;
        f->count_allocated += 1;
        return i;
      }
    }
    assert(0);
  }

  void leave(Storage* f, int which) {
    assert(f->count_allocated > 0);
    assert(f->allocated[which]);
    f->count_allocated -= 1;
    f->allocated[which] = 0;
  }
end

native @nohold _assert();

native _random_plusminus();

native @plain _Queue;
native @nohold _set_empty_queue();
native @nohold _push();
native @nohold _empty();
native @nohold _pop();

native @plain _Storage;
native @nohold _set_empty_storage();
native @nohold _full();
native @nohold _enter();
native @nohold _leave();

class Barber with
  var _Queue queue;
  var _Storage storage;
  event int next;
  var int current = -1;
  function (void)=>int get_next_id;
do
  _set_empty_queue(&queue);
  _set_empty_storage(&storage);
  var int next_id = 1;
  function (void)=>int get_next_id do
    next_id = next_id + 1;
    return next_id - 1;
  end
end

class Customer with
  var Barber& barber;
  var Kind& kind;
  var _SDL_Renderer[] ren;
do
  var int id = barber.get_next_id();
  if barber.current == -1 then
    barber.current = id;
    var Object* rep = spawn Object with
      this.kind = kind;
      this.ren = ren;
      this.x = 10;
      this.y = 10;
      this.destx = 400;
      this.desty = 10;
    end;
    _assert(rep);
    watching rep do
      await 2s;
      (*rep).x = 400;
      (*rep).y = 10;
      emit (*rep).move => (400, 300);
      await (_random_plusminus(15, 3))s;
      if _empty(&barber.queue) then
        barber.current = -1;
      else
        var int next_id = _pop(&barber.queue);
        barber.current = next_id;
        emit barber.next => next_id;
      end
      (*rep).x = 400;
      (*rep).y = 300;
      emit (*rep).move => (10, 580);
      await 2s;
      emit (*rep).destroy;
    end
  else/if _full(&barber.storage) then
    var Object* rep = spawn Object with
      this.kind = kind;
      this.ren = ren;
      this.x = 10;
      this.y = 10;
      this.destx = 10;
      this.desty = 580;
    end;
    _assert(rep);
    watching rep do
      await 2s;
      emit (*rep).destroy;
    end
  else
    var int which_seat = _enter(&barber.storage);
    _push(&barber.queue, id);
    var Object* rep = spawn Object with
      this.kind = kind;
      this.ren = ren;
      this.x = 10;
      this.y = 10;
      this.destx = 400;
      this.desty = 10;
    end;
    watching rep do
      par/or do
        var int next = await barber.next until next == id;
      with
        await 2s;
        (*rep).x = 400;
        (*rep).y = 10;
        emit (*rep).move => (780, 10+25*which_seat);
        await FOREVER;
      end
      _leave(&barber.storage, which_seat);
      emit (*rep).move => (400, 300);
      await (_random_plusminus(15, 3))s;
      if _empty(&barber.queue) then
        barber.current = -1;
      else
        var int next_id = _pop(&barber.queue);
        barber.current = next_id;
        emit barber.next => next_id;
      end
      (*rep).x = 400;
      (*rep).y = 300;
      emit (*rep).move => (10, 580);
      await 2s;
      emit (*rep).destroy;
    end
  end
end


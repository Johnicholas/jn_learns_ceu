#include "sdl_animator.ceu"

native do
  #include <assert.h>

  int random_plusminus(int center, int plusminus) {
    return center - plusminus + rand() % (plusminus * 2);
  }
end

native @nohold _assert();

class BarberQueue with
  var int servers_minus_clients_waiting = 0;
  // a client sees there are some idle servers and asks for one
  event BarberCustomer* next_server;
  // an available server sees that there are some idle clients and asks for one
  event Barber* next_client;
do
  // nothing
end

interface BarberCustomer with
  var Barber[] my_barber;
  var int id;
end

class Barber with
  var Kind& kind;
  var _SDL_Renderer[] ren;
  var int id;
  var BarberQueue& queue;
  var BarberCustomer* my_client = null;
  event void done;
do
  var Object rep with
    this.kind = kind;
    this.ren = ren;
    this.x = 400+25*id;
    this.y = 300;
    this.destx = 400+25*id;
    this.desty = 300;
  end;
  loop do
    if queue.servers_minus_clients_waiting >= 0 then
      var int count = queue.servers_minus_clients_waiting;
      queue.servers_minus_clients_waiting = queue.servers_minus_clients_waiting + 1;
      loop i in count do
        await queue.next_server;
      end
      my_client = await queue.next_server;
      queue.servers_minus_clients_waiting = queue.servers_minus_clients_waiting - 1;
      my_client:my_barber = &this;
    else
      emit queue.next_client => &this; // reply by mutating my_client
    end
    watching my_client do
      emit rep.move => (rep.x, rep.y - 10);
      await 2s;
      _printf("barber %d cuts customer %d's hair\n", id, my_client:id);
      await (_random_plusminus(30000, 6000))ms;
      emit done;
      _printf("barber %d is done cutting customer %d's hair\n", id, my_client:id);
    end
    emit rep.move => (rep.x, rep.y + 10);
    await 2s;
  end
end

class ChairQueue with
  var int servers_minus_clients_waiting = 0;
  // a client sees there are some idle servers and asks for one
  event ChairCustomer* next_server;
  // an available server sees that there are some idle clients and asks for one
  event Chair* next_client;
do
  // nothing
end

interface ChairCustomer with
  event void stand_up;
  var Chair[] my_chair;
end

class Chair with
  var Kind& kind;
  var _SDL_Renderer[] ren;
  var int id;
  var ChairQueue& queue;
  var ChairCustomer* my_client = null;
do
  var Object rep with
    this.kind = kind;
    this.ren = ren;
    this.x = 780;
    this.y = 10+25*id;
    this.destx = 780;
    this.desty = 10+25*id;
  end;
  loop do
    _assert(queue.servers_minus_clients_waiting >= 0);
    var int count = queue.servers_minus_clients_waiting;
    queue.servers_minus_clients_waiting = queue.servers_minus_clients_waiting + 1;
    loop i in count do
      await queue.next_server;
    end
    my_client = await queue.next_server;
    queue.servers_minus_clients_waiting = queue.servers_minus_clients_waiting - 1;
    my_client:my_chair = &this;
    emit rep.move => (rep.x - 10, rep.y);
    await my_client:stand_up;
    emit rep.move => (rep.x + 10, rep.y);
    await 1s;
  end
end


class Customer with
  interface BarberCustomer;
  interface ChairCustomer;
  var BarberQueue& barbers;
  var ChairQueue& chairs;
  var Kind& kind;
  var _SDL_Renderer[] ren;
do
  my_barber = null;
  emit barbers.next_server => &this;
  if my_barber then
    // go directly to barber, without waiting in a chair
    var Object rep with
      this.kind = kind;
      this.ren = ren;
      this.x = 10;
      this.y = 10;
      this.destx = 400+25*my_barber:id;
      this.desty = 275;
    end;
    await my_barber:done;
    emit rep.move => (10, 580);
    await 2s;
  else
    // sit down in a chair until a barber is available
    my_chair = null;
    emit chairs.next_server => &this;
    if my_chair then
      var int count = -1 * barbers.servers_minus_clients_waiting;
      barbers.servers_minus_clients_waiting = barbers.servers_minus_clients_waiting - 1;
      var Object rep with
        this.kind = kind;
        this.ren = ren;
        this.x = 10;
        this.y = 10;
        this.destx = 755;
        this.desty = 10+25*my_chair:id;
      end;
      loop i in count do
        await barbers.next_client;
      end
      my_barber = await barbers.next_client;
      my_barber:my_client = &this;
      barbers.servers_minus_clients_waiting = barbers.servers_minus_clients_waiting + 1;
      emit stand_up;
      emit rep.move => (400+25*my_barber:id, 275);
      await my_barber:done;
      emit rep.move => (10, 580);
      await 2s;
    else
      // balk
      var Object rep with
        this.kind = kind;
        this.ren = ren;
        this.x = 10;
        this.y = 10;
        this.destx = 10;
        this.desty = 580;
      end;
      await 2s;
    end
  end
end


#include "sdl_animator.ceu"

native do
  #include <assert.h>

  int random_plusminus(int center, int plusminus) {
    return center - plusminus + rand() % (plusminus * 2);
  }
end

native @nohold _assert();

class BarberQueue with
  var int servers_minus_clients_waiting = 0;
  // a client sees there are some idle servers and asks for one
  event BarberCustomer* next_server;
  // an available server sees that there are some idle clients and asks for one
  event Barber* next_client;
do
  // nothing
end

interface BarberCustomer with
  var Barber[] my_barber;
  event void ok_arrived;
end

class Barber with
  var Kind& kind;
  var _SDL_Renderer[] ren;
  var int id;
  var BarberQueue& queue;
  var BarberCustomer* my_client = null;
  event void ok_done;
do
  var Object rep with
    this.kind = kind;
    this.ren = ren;
    this.x = 400+25*id;
    this.y = 300;
    this.destx = 400+25*id;
    this.desty = 300;
  end;
  loop do
    if queue.servers_minus_clients_waiting >= 0 then
      var int count = queue.servers_minus_clients_waiting;
      queue.servers_minus_clients_waiting = queue.servers_minus_clients_waiting + 1;
      loop i in count do
        await queue.next_server;
      end
      my_client = await queue.next_server;
      queue.servers_minus_clients_waiting = queue.servers_minus_clients_waiting - 1;
      my_client:my_barber = &this;
    else
      emit queue.next_client => &this; // reply by mutating my_client
    end
    watching my_client do
      emit rep.go_move => (rep.x, 290);
      par/and do
        await 2s;
      with
        await rep.ok_moved until rep.y == 290;
      with
        await my_client:ok_arrived;
      end
      _printf("barber %d starts cutting hair\n", id);
      await (_random_plusminus(30000, 6000))ms;
      emit ok_done;
      _printf("barber %d is done\n", id);
    end
    emit rep.go_move => (rep.x, 300);
    par/and do
      await 2s;
    with
      await rep.ok_moved until rep.y == 300;
    end
  end
end

class ChairQueue with
  var int servers_minus_clients_waiting = 0;
  // a client sees there are some idle servers and asks for one
  event ChairCustomer* next_server;
  // an available server sees that there are some idle clients and asks for one
  event Chair* next_client;
do
  // nothing
end

interface ChairCustomer with
  event void ok_standing_up;
  event void ok_arrived_at_chair;
  var Chair[] my_chair;
end

class Chair with
  var Kind& kind;
  var _SDL_Renderer[] ren;
  var int id;
  var ChairQueue& queue;
  var ChairCustomer* my_client = null;
do
  var Object rep with
    this.kind = kind;
    this.ren = ren;
    this.x = 780;
    this.y = 10+25*id;
    this.destx = 780;
    this.desty = 10+25*id;
  end;
  loop do
    _assert(queue.servers_minus_clients_waiting >= 0);
    var int count = queue.servers_minus_clients_waiting;
    queue.servers_minus_clients_waiting = queue.servers_minus_clients_waiting + 1;
    loop i in count do
      await queue.next_server;
    end
    my_client = await queue.next_server;
    queue.servers_minus_clients_waiting = queue.servers_minus_clients_waiting - 1;
    my_client:my_chair = &this;
    watching my_client do
      await my_client:ok_arrived_at_chair;
      emit rep.go_move => (rep.x - 10, rep.y);
      await my_client:ok_standing_up;
    end
    emit rep.go_move => (rep.x + 10, rep.y);
    par/and do
      await 1s;
    with
      await rep.ok_moved;
    end
  end
end


class Customer with
  interface BarberCustomer;
  interface ChairCustomer;
  var BarberQueue& barbers;
  var ChairQueue& chairs;
  var Kind& kind;
  var _SDL_Renderer[] ren;
do
  my_barber = null;
  emit barbers.next_server => &this;
  if my_barber then
    // go directly to barber, without waiting in a chair
    var Object rep with
      this.kind = kind;
      this.ren = ren;
      this.x = 10;
      this.y = 10;
      this.destx = 400+25*my_barber:id;
      this.desty = 275;
    end;
    par/and do
      await 2s;
    with
      await rep.ok_moved;
    end
    emit ok_arrived;
    await my_barber:ok_done;
    emit rep.go_move => (10, 580);
    par/and do
      await 2s;
    with
      await rep.ok_moved;
    end
  else
    // sit down in a chair until a barber is available
    my_chair = null;
    emit chairs.next_server => &this;
    if my_chair then
      var int count = -1 * barbers.servers_minus_clients_waiting;
      barbers.servers_minus_clients_waiting = barbers.servers_minus_clients_waiting - 1;
      var Object rep with
        this.kind = kind;
        this.ren = ren;
        this.x = 10;
        this.y = 10;
        this.destx = 755;
        this.desty = 10+25*my_chair:id;
      end;
      par/or do
        await rep.ok_moved;
        emit ok_arrived_at_chair;
        await FOREVER;
      with
        loop i in count do
          await barbers.next_client;
        end
        my_barber = await barbers.next_client;
      end
      my_barber:my_client = &this;
      barbers.servers_minus_clients_waiting = barbers.servers_minus_clients_waiting + 1;
      emit ok_standing_up;
      emit rep.go_move => (400+25*my_barber:id, 275);
      par/and do
        await 2s;
      with
        await rep.ok_moved;
      end
      emit ok_arrived;
      await my_barber:ok_done;
      emit rep.go_move => (10, 580);
      par/and do
        await 2s;
      with
        await rep.ok_moved;
      end
    else
      // balk
      var Object rep with
        this.kind = kind;
        this.ren = ren;
        this.x = 10;
        this.y = 10;
        this.destx = 10;
        this.desty = 580;
      end;
      par/and do
        await 2s;
      with
        await rep.ok_moved;
      end
    end
  end
end


#include "sdl_animator.ceu"

native do
  #include <assert.h>

  int random_plusminus(int center, int plusminus) {
    return center - plusminus + rand() % (plusminus * 2);
  }
end

native @nohold _assert();

#define SYNC(r) \
  if r.waiting then r.waiting = false; emit r.ready; else r.waiting = true; await r.ready; end

class Rendesvous with
  function (void)=>bool client_volunteers;
  function (int, int)=>bool server_volunteers;
  var bool waiting = false;
  event void ready;
  event void over;
  function (void)=>bool was_accepted;
  var int x = 50;
  var int y = 50;
do
  var bool need_client = true;
  var bool need_server = true;

  function (void)=>bool client_volunteers do
    if need_client then
      need_client = false;
      return true;
    else
      return false;
    end
  end
  
  function (int new_x, int new_y)=>bool server_volunteers do
    if need_server then
      need_server = false;
      x = new_x;
      y = new_y;
      return true;
    else
      return false;
    end
  end

  function (void)=>bool was_accepted do
    return not need_client and not need_server;
  end
end

class Queue with
  event Rendesvous* next;
do
  // nothing
end

class Barber with
  var Kind& kind;
  var _SDL_Renderer[] ren;
  var int id;
  var Queue& customers;
do
  var Object rep with
    this.kind = kind;
    this.ren = ren;
    this.x = 400+25*id;
    this.y = 300;
    this.destx = 400+25*id;
    this.desty = 300;
  end;

  loop do
    await 1ms; // TODO: necessary?
    // try to get a client
    var Rendesvous r;
    r.server_volunteers(rep.x, 275);
    emit customers.next => &r;
    if r.was_accepted() then
      // step forward to meet the client
      var int count = 0;
      emit rep.go_move => (&count, rep.x, 290);
      _assert(count == 1);
      await rep.ok_moved;
      SYNC(r);
      await (_random_plusminus(30000, 6000))ms;
      emit r.over;
    else
      // when a client asks for a server, volunteer self
      var Rendesvous[] rptr = null;
      loop do
        rptr = await customers.next;
        if rptr:server_volunteers(rep.x, 275) then
          break;
        else
          rptr = null;
        end
      end
      // step forward to meet the client
      var int count = 0;
      emit rep.go_move => (&count, rep.x, 290);
      _assert(count == 1);
      await rep.ok_moved;
      SYNC((*rptr));
      await (_random_plusminus(30000, 6000))ms;
      emit rptr:over;
    end

    // step back and clean up the station
    var int count = 0;
    emit rep.go_move => (&count, rep.x, 300);
    _assert(count == 1);
    await rep.ok_moved;
  end
end

class Chair with
  var Kind& kind;
  var _SDL_Renderer[] ren;
  var int id;
  var Queue& customers;
do
  var Object rep with
    this.kind = kind;
    this.ren = ren;
    this.x = 780;
    this.y = 10+25*id;
    this.destx = 780;
    this.desty = 10+25*id;
  end;

  loop do
    await 1ms; // TODO: necessary?
    // when a client asks for a server, volunteer self
    var Rendesvous[] rptr = null;
    loop do
      rptr = await customers.next;
      if rptr:server_volunteers(755, rep.y) then
        break;
      else
        rptr = null;
      end
    end
    // as they sit down, the chair moves forward a little bit.
    var int count = 0;
    emit rep.go_move => (&count, 770, rep.y);
    _assert(count == 1);
    await rep.ok_moved;
    SYNC((*rptr));
    await (_random_plusminus(30000, 6000))ms;
    emit rptr:over;

    // as they stand up, the chair moves backward a little bit.
    count = 0;
    emit rep.go_move => (&count, 780, rep.y);
    _assert(count == 1);
    await rep.ok_moved;
  end
end

class Customer with
  var Queue& barbers;
  var Queue& chairs;
  var Kind& kind;
  var _SDL_Renderer[] ren;
  var int id;
do
  // enter stage left
  var Object rep with
    this.kind = kind;
    this.ren = ren;
    this.x = 10;
    this.y = 10;
    this.destx = 400;
    this.desty = 10;
  end;
  await rep.ok_moved;
  await 1ms; // TODO: necessary?
  // try to get a barber
  var Rendesvous r;
  r.client_volunteers();
  emit barbers.next => &r;
  if r.was_accepted() then
    // go to the barber
    var int count = 0;
    emit rep.go_move => (&count, r.x, r.y);
    _assert(count == 1);
    await rep.ok_moved;
    SYNC(r);
    await r.over;
  else
    var Rendesvous chair_r;
    chair_r.client_volunteers();
    emit chairs.next => &chair_r;
    if chair_r.was_accepted() then
      var Rendesvous[] rptr = null;
      par/or do
        // when a client asks for a server, volunteer self
        loop do
          rptr = await barbers.next;
          if rptr:client_volunteers() then
            break;
          else
            rptr = null;
          end
        end
      with
        var int count = 0;
        emit rep.go_move => (&count, chair_r.x, chair_r.y);
        _assert(count == 1);
        await rep.ok_moved;
        // TODO: go to the chair?
        await FOREVER;
      end
      var int count = 0;
      emit rep.go_move => (&count, rptr:x, rptr:y);
      _assert(count == 1);
      await rep.ok_moved;
      SYNC((*rptr));
      await rptr:over;
    else
      // balk
    end
  end
  // leave
  await 1ms; // TODO: necessary?
  var int count = 0;
  emit rep.go_move => (&count, 10, 580);
  _assert(count == 1);
  await rep.ok_moved;
end



native do
  typedef struct CEU_T CEU_T;
  typedef struct {
    struct CEU_T** backing;
    int size;
  } heap;

  void insert(heap* container, CEU_T* elem);
  void deletemin(heap* container);
end
native @plain _heap;
native _insert();
native _deletemin();
native @nohold _sb_free();

input void TICK;

class T with
  var int cost;
  event void go_kill;
do
  await go_kill;
end

#define INSERT(HEAP, COST) \
  do \
    var T[] newt = spawn T in thepool with \
      this.cost = COST; \
    end; \
    _insert(&HEAP, newt) finalize with /* nothing? */ end; \
  end

#define DELETEMIN(HEAP) \
  do \
    var T[] front = HEAP.backing[1]; \
    emit front:go_kill; \
    _deletemin(&HEAP) finalize with /* nothing? */ end; \
  end

pool T[] thepool;
var _heap theheap;
theheap.backing = null;
theheap.size = 0;
// we put one "wasted" element into the stretchy buffer,
// so that the heap indexes can start with 1 rather than 0.
var T[] wasted = spawn T with
  this.cost = 123456;
end;
_sb_push(theheap.backing, wasted) finalize with
  _sb_free(theheap.backing);
end;


#define BIG 10000
loop i in BIG do
  if _rand()%(BIG-i) > theheap.size then
    var int to_insert = _rand() % 100000;
    _printf("insert %05d\n", to_insert);
    INSERT(theheap, to_insert);
  else/if theheap.size > 0 then
    var T[] front = theheap.backing[1];
    _printf("pop    %05d\n", front:cost);
    DELETEMIN(theheap);
  end
end


escape 0;


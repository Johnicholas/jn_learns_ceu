// Adapted from Rosetta Code: rosettacode.org/wiki/Dijkstra%27s_algorithm
native @nohold _assert();
native @nohold _sscanf();
native @nohold _getline();
native @nohold _free();
native @nohold _printf();

native do
  // forward declaration
  typedef struct CEU_Node CEU_Node;
end

class Edge with
  var Node[] target; // node you would arrive at if you traversed this edge
  var float cost; // cost to traverse this edge
  var Edge[] sibling; // internal linked-list of edges leading out from the same node
do
  // nothing?
  await FOREVER;
end

class Node with
  var Edge[] out = null; // singly linked list of outgoing edges from this node
  var Node[] via = null; // previous node in shortest path
  var float cost = 0.0; // total cost from origin node
  var char name;
  var int heap_index; // the position of this node in the heap
do
  // nothing?
  await FOREVER;
end

#define ADD_EDGE(a, b, cost)  \
  do \
    var Edge[] new_edge = spawn Edge with \
      this.target = b; \
      this.cost = cost; \
      this.sibling = a:out; \
    end; \
    a:out = new_edge; \
  end 

function @rec (Node*)=>void show_path;

function @rec (Node* n)=>void show_path do
  if n:via == n then
    _printf("%c", n:name);
  else/if n:via == null then
    _printf("unreached");
  else
    call/rec show_path(n:via);
    _printf("-> %c ", n:name);
  end
end

var char* line = null;
var _size_t len = 0;
var _ssize_t read;
finalize 
  read = _getline(&line, &len, _stdin);
with
  _free(line);
end
_assert(read != -1);
var int num_nodes;
_assert(_sscanf(line, "%d", &num_nodes) == 1);
_assert(num_nodes > 0);
_assert(num_nodes < 100);
pool Node[] nodes;
loop i in num_nodes do
  spawn Node in nodes with
    this.name = 'a' + i;
  end;
end
finalize
  read = _getline(&line, &len, _stdin);
with
  // nothing - already being freed
end
_assert(read != -1);
var int num_edges;
_assert(_sscanf(line, "%d", &num_edges) == 1);
loop i in num_edges do
  var char source_name, target_name;
  var float cost;
  finalize
    read = _getline(&line, &len, _stdin);
  with
    // nothing - already being freed
  end
  _assert(read != -1);
  _sscanf(line, "%c %c %f", &source_name, &target_name, &cost);
  var Node[] source = null;
  var Node[] target = null;
  // find source by name
  var bool found = false;
  loop (Node*)x in nodes do
    if x:name == source_name then
      source = x;
      found = true;
      break;
    end
  end
  _assert(found);
  found = false;
  // find target by name
  loop (Node*)y in nodes do
    if y:name == target_name then
      target = y;
      found = true;
      break;
    end
  end
  _assert(found);
  ADD_EDGE(source, target, cost);
end
var Node[] start = null;
// find start node by name
var bool found = false;
loop (Node*)z in nodes do
  if z:name == 'a' then
    start = z;
    found = true;
    break;
  end
end
_assert(found);
// a  vector of pointers to node organisms
var Node*[100] heap; // TODO: this hardcoded 100 seems dubious. Is there a way to get rid of it?
start:heap_index = 1;
start:via = start;
start:cost = 0.0;
heap[1] = start;
var int heap_len = 1;
loop do
  _assert(heap_len >= 0);
  if heap_len == 0 then
    // frontier is empty
    break;
  end
  var Node* lead = heap[1];
  var Node* temp = heap[heap_len];
  _assert(temp);
  heap_len = heap_len - 1;
  var int i = 1;
  var int j;
  loop do
    if i >= heap_len then
      break;
    else
      j = i * 2;
      if j > heap_len then
        break;
      end
    end
    if j < heap_len and heap[j]:cost > heap[j+1]:cost then
      j = j + 1;
    end
    if heap[j]:cost >= temp:cost then
      break;
    end
    heap[i] = heap[j];
    heap[i]:heap_index = i;
    i = j;
  end
  heap[i] = temp;
  temp:heap_index = i;
  var Edge[] e = lead:out;
  loop do
    if e == null then
      break;
    end
    if e:target:via != null and e:target:cost < lead:cost + e:cost then
      // found a second route, but it is longer
      e = e:sibling;
      continue;
    end
    e:target:cost = lead:cost + e:cost;
    e:target:via = lead;
    i = e:target:heap_index;
    if i == 0 then
      i = heap_len + 1;
      heap_len = heap_len + 1;
    end
    loop do
      if i <= 1 then
        break;
      else
        j = i / 2;
        if e:target:cost >= heap[j]:cost then
          break;
        end
      end
      heap[i] = heap[j];
      heap[i]:heap_index = i;
      i = j;
    end
    heap[i] = e:target;
    e:target:heap_index = i;
    e = e:sibling;
  end
end

loop (Node*)node in nodes do
  _printf("path to %c (total cost %f) ", node:name, node:cost);
  call/rec show_path(node);
  _putchar('\n');
end

escape 0;

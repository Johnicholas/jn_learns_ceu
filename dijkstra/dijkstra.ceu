// Adapted from Rosetta Code: rosettacode.org/wiki/Dijkstra%27s_algorithm
native @nohold _assert();
native @nohold _printf();
input void TICK;

native do
  // forward declaration
  typedef struct CEU_Node CEU_Node;
end

class Edge with
  var Node[] target; // node you would arrive at if you traversed this edge
  var float cost; // cost to traverse this edge
  var Edge[] sibling; // internal linked-list of edges leading out from the same node
do
  // nothing?
  await FOREVER;
end

class Node with
  var Edge[] out = null; // singly linked list of outgoing edges from this node
  var char name;
do
  // nothing?
  await FOREVER;
end

#define ADD_EDGE(a, b, c)  \
  do \
    var Edge[] new_edge = spawn Edge with \
      this.target = b; \
      this.cost = c; \
      this.sibling = a:out; \
    end; \
    a:out = new_edge; \
  end 


pool Node[] nodes;
var Node[] start;

// the graph - mucking about with string parsing was obscuring the substance
do
  var Node[] a = spawn Node in nodes with this.name = 'a'; end;
  var Node[] b = spawn Node in nodes with this.name = 'b'; end;
  var Node[] c = spawn Node in nodes with this.name = 'c'; end;
  var Node[] d = spawn Node in nodes with this.name = 'd'; end;
  var Node[] e = spawn Node in nodes with this.name = 'e'; end;
  var Node[] f = spawn Node in nodes with this.name = 'f'; end;
  var Node[] g = spawn Node in nodes with this.name = 'g'; end;

  ADD_EDGE(a, b, 3.0);
  ADD_EDGE(a, c, 5.0);
  ADD_EDGE(a, d, 6.0);
  ADD_EDGE(b, a, 3.0);
  ADD_EDGE(b, d, 2.0);
  ADD_EDGE(c, a, 5.0);
  ADD_EDGE(c, d, 2.0);
  ADD_EDGE(c, f, 3.0);
  ADD_EDGE(c, e, 6.0);
  ADD_EDGE(c, g, 7.0);
  ADD_EDGE(d, a, 6.0);
  ADD_EDGE(d, b, 2.0);
  ADD_EDGE(d, c, 2.0);
  ADD_EDGE(d, f, 9.0);
  ADD_EDGE(e, c, 6.0);
  ADD_EDGE(e, f, 5.0);
  ADD_EDGE(e, g, 2.0);
  ADD_EDGE(f, c, 3.0);
  ADD_EDGE(f, d, 9.0);
  ADD_EDGE(f, e, 5.0);
  ADD_EDGE(f, g, 1.0);
  ADD_EDGE(g, c, 7.0);
  ADD_EDGE(g, e, 2.0);
  ADD_EDGE(g, f, 1.0);

  start = a;
end

class Dijkstra with
  event Elem** ok_front;
do
  // nothing?
  await FOREVER;
end

class Elem with
  var Node[] n;
  var float cost = 0.0; // total cost from origin node
  event void go_pop;
  var Dijkstra& context;
  var Elem[] via = null;
do
  par/or do
    loop do
      var Elem** candidate = await context.ok_front;
      if *candidate == null or (*candidate):cost > cost then
        *candidate = &this;
      end
    end
  with
    await go_pop;
  end
  await FOREVER;
end


function @rec (Elem*)=>void show_path;
function @rec (Elem* e)=>void show_path do
  if e:via == null then
    _printf("%c", e:n:name);
  else
    call/rec show_path(e:via);
    _printf("-> %c ", e:n:name);
  end
end

var Dijkstra context;
// a  vector of pointers to node organisms
pool Elem[] heap;
spawn Elem in heap with
  this.n = start;
  this.cost = 0.0;
  this.context = context;
end;
loop do

  // pull the thing with the least cost from the heap
  // TODO: ideally, this would only take logarithmic time, but we're spending linear time
  await TICK;
  var Elem[] lead = null;
  emit context.ok_front => &lead;

  if lead == null then
    // frontier is empty
    break;
  end

  var Edge[] e = lead:n:out;
  loop do
    if e == null then
      break;
    end

    // find e:target's corresponding heap elem, if it has one
    // TODO: ideally this would take O(1) time, but we're taking linear time
    var Elem[] corresponding = null;
    loop (Elem*)x in heap do
      if x:n == e:target then
        corresponding = x;
        break;
      end
    end
    if corresponding == null then
      // put e:target into the heap
      spawn Elem in heap with
        this.n = e:target;
        this.cost = lead:cost + e:cost;
        this.context = context;
        this.via = lead;
      end;
    else/if corresponding:cost > lead:cost + e:cost then
      // we found another way to get here, and it is better
      corresponding:cost = lead:cost + e:cost;
      corresponding:via = lead;
    end
    e = e:sibling;
  end
  _printf("path to %c has total cost %f:", lead:n:name, lead:cost);
  call/rec show_path(lead);
  _printf("\n");
  emit lead:go_pop;
end

escape 0;

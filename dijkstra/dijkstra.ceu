// Adapted from Rosetta Code: rosettacode.org/wiki/Dijkstra%27s_algorithm
native @nohold _assert();
native @nohold _printf();
input void TICK;

native do
  // forward declaration
  typedef struct CEU_Node CEU_Node;
end

class Edge with
  var Node[] target; // node you would arrive at if you traversed this edge
  var float cost; // cost to traverse this edge
  var Edge[] sibling; // internal linked-list of edges leading out from the same node
do
  // nothing?
  await FOREVER;
end

class Node with
  var Edge[] out = null; // singly linked list of outgoing edges from this node
  var char name;
do
  // nothing?
  await FOREVER;
end

#define ADD_EDGE(a, b, c)  \
  do \
    var Edge[] new_edge = spawn Edge with \
      this.target = b; \
      this.cost = c; \
      this.sibling = a:out; \
    end; \
    a:out = new_edge; \
  end 


pool Node[] nodes;
var Node[] start;

// the graph - mucking about with string parsing was obscuring the substance
do
  var Node[] a = spawn Node in nodes with this.name = 'a'; end;
  var Node[] b = spawn Node in nodes with this.name = 'b'; end;
  var Node[] c = spawn Node in nodes with this.name = 'c'; end;
  var Node[] d = spawn Node in nodes with this.name = 'd'; end;
  var Node[] e = spawn Node in nodes with this.name = 'e'; end;
  var Node[] f = spawn Node in nodes with this.name = 'f'; end;
  var Node[] g = spawn Node in nodes with this.name = 'g'; end;

  ADD_EDGE(a, b, 3.0);
  ADD_EDGE(a, c, 5.0);
  ADD_EDGE(a, d, 6.0);
  ADD_EDGE(b, a, 3.0);
  ADD_EDGE(b, d, 2.0);
  ADD_EDGE(c, a, 5.0);
  ADD_EDGE(c, d, 2.0);
  ADD_EDGE(c, f, 3.0);
  ADD_EDGE(c, e, 6.0);
  ADD_EDGE(c, g, 7.0);
  ADD_EDGE(d, a, 6.0);
  ADD_EDGE(d, b, 2.0);
  ADD_EDGE(d, c, 2.0);
  ADD_EDGE(d, f, 9.0);
  ADD_EDGE(e, c, 6.0);
  ADD_EDGE(e, f, 5.0);
  ADD_EDGE(e, g, 2.0);
  ADD_EDGE(f, c, 3.0);
  ADD_EDGE(f, d, 9.0);
  ADD_EDGE(f, e, 5.0);
  ADD_EDGE(f, g, 1.0);
  ADD_EDGE(g, c, 7.0);
  ADD_EDGE(g, e, 2.0);
  ADD_EDGE(g, f, 1.0);

  start = a;
end

interface DijkstraContext with
  var DijkstraElem[] lead;
  var bool closed;
  event void tick;
  event void checkclosed;
end
 
class DijkstraElem with
  var Node[] n;
  var DijkstraElem[] via = null;
  var float cost; // total cost from origin node
  event void go_pop;
  var DijkstraContext& context;
do
  par/or do
    every context.tick do
      if context.lead == null or context.lead:cost > cost then
        context.lead = &this;
      end
    end
  with
    await go_pop;
  end
  // switch from being in "open" to being in "closed"
  every context.checkclosed do
    if context.lead:n == n then
      context.closed = true;
    end
  end
end

class Dijkstra with
  interface DijkstraContext;
  var Node[] start;
  event void tick;
  event void ok;
do
  par/or do
    every tick do
      lead = null;
    end
  with
    pool DijkstraElem[] heap;
    spawn DijkstraElem in heap with
      this.n = start;
      this.cost = 0.0;
      this.context = outer;
    end;
    loop do
      await tick;
      if lead == null then
        break;
      end
      closed = false;
      emit checkclosed;
      if closed then
        emit lead:go_pop;
        continue;
      end
      var Edge[] e = lead:n:out;
      loop do
        if e == null then
          break;
        end
        spawn DijkstraElem in heap with
          this.n = e:target;
          this.via = lead;
          this.cost = lead:cost + e:cost;
          this.context = outer;
        end;
        e = e:sibling;
      end
      _printf("path to %c found, cost is %f, in reverse is: ", lead:n:name, lead:cost);
      var DijkstraElem[] cursor = lead:via;
      loop do
        if cursor == null then
          break;
        end
        _printf("%c ", cursor:n:name);
        cursor = cursor:via;
      end
      _printf("\n");
      emit lead:go_pop;
    end
  end
  emit ok;
end

var Dijkstra the_algorithm with
  this.start = start;
end;
par/or do
  every TICK do
    emit the_algorithm.tick;
  end
with
  await the_algorithm.ok;
end


escape 0;


input int REMOTE_WORKER_DONE;
input int USER_TASK;
native @plain _Queue;
native @nohold _init();
native @nohold _push();
native @nohold _empty();
native @nohold _pop();
native @nohold _assert();

interface UnableToName with
  event Worker* done;
end

class Worker with
  var UnableToName& done_channel;
  var int details;
  var int id;
  var bool done = false;
do
  loop do
    _start_remote_task(details, id);
    var int reply_to = await REMOTE_WORKER_DONE until reply_to == id;
    _printf("Worker #%d done with %d\n", id, details);
    done = true;
    emit done_channel.done => &this;
    if done then
      _printf("Worker #%d done with all tasks\n", id);
      break;
    else
      _printf("Worker #%d got new task %d\n", id, details);
    end
  end
end

class ResourceManager with
  interface UnableToName;
  event int go_task;
do
  pool Worker[3] resources;
  var int nextid = 1;
  var _Queue queue;
  _init(&queue);

  par do
    var int details;
    every details in this.go_task do
      var Worker* spawned = spawn Worker in resources with
        this.id = nextid;
        this.details = details;
        this.done_channel = outer;
      end;
      if spawned then
        nextid = nextid + 1;
      else
        _printf("All workers are unavailable, so ResourceManager stores %d in a queue\n", details);
        _push(&queue, details);
      end
    end
  with
    var Worker* w;
    every w in done do
      if not _empty(&queue) then
        var int d = _pop(&queue);
        _printf("ResourceManager sees something is done and queue is nonempty, so starting work on %d\n", d);
        (*w).details = d;
        (*w).done = false;
      else
        _printf("ResourceManager sees something is done and queue is empty, so something is now idle\n");
      end
    end
  end
end

var ResourceManager r;
var int details;
every details in USER_TASK do
  emit r.go_task => details;
end


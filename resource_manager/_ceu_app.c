/*
 * This file is automatically generated.
 * Check the github repository for a readable version:
 * http://github.com/fsantanna/ceu
 *
 * CÃ©u is distributed under the MIT License:
 *

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#line 1 "hello.ceu"

#ifndef _CEU_APP_H
#define _CEU_APP_H

#include "ceu_types.h"

#define CEU_INTS
#define CEU_EXTS
#define CEU_ORGS
#define CEU_CLEAR
#define CEU_IFCS
     /* CEU_EXTS, CEU_WCLOCKS, CEU_INTS, ... */

/* TODO: lbl => unsigned */
#ifndef CEU_OS
typedef s8 tceu_nlbl;
#endif

#ifdef CEU_IFCS
/* (x) number of different classes */
typedef s8 tceu_ncls;
#endif

/* TODO: remove */
#define CEU_NTRAILS 5

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#if defined(CEU_OS) && defined(__AVR)
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#ifdef __cplusplus
#define CEU_EVTP(v) (tceu_evtp(v))
#else
#define CEU_EVTP(v) ((tceu_evtp)v)
#endif

#ifdef CEU_OS
    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    #define CEU_PSES
    #define CEU_NEWS
    #define CEU_NEWS_MALLOC
    #define CEU_NEWS_POOL
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__INIT        252
    #define CEU_IN__CLEAR       251
    #define CEU_IN__WCLOCK      250
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              244
#endif

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

    #define ceu_out_malloc(size) \
        ((__typeof__(ceu_sys_malloc)*)((_ceu_app)->sys_vec[CEU_SYS_MALLOC]))(size)
    #define ceu_out_free(ptr) \
        ((__typeof__(ceu_sys_free)*)((_ceu_app)->sys_vec[CEU_SYS_FREE]))(ptr)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_clear(go,start,stop) \
        ((__typeof__(ceu_sys_clear)*)((_ceu_app)->sys_vec[CEU_SYS_CLEAR]))(go,start,stop)

    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,seqno,isDyn,par_org,par_trl)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_SPAWN]))(go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit_buf(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,CEU_EVTP((void*)NULL),sz,buf)

    #define ceu_out_emit_val(app,id,param) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,param,0,NULL)

    #define ceu_out_call_val(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS */
    #define ceu_out_malloc(size) \
            ceu_sys_malloc(size)
    #define ceu_out_free(ptr) \
            ceu_sys_free(ptr)
    #define ceu_out_req() \
            ceu_sys_req()
#ifdef CEU_CLEAR
    #define ceu_out_clear(go,start,stop) \
            ceu_sys_clear(go,start,stop)
#endif
#ifdef CEU_NEWS
    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,isDyn,par_org,par_trl)
#else
    #define ceu_out_org(app,org,n,lbl,seqno,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,par_org,par_trl)
#endif
#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(go, lbl_cnt, org, lbl_org)
#endif
/*#ifdef ceu_out_emit_val*/
    #define ceu_out_emit_buf(app,id,sz,buf) \
            ceu_out_emit_val(app,id,CEU_EVTP((void*)buf))
/*#endif*/
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
#endif

#define ceu_in_emit_val(app,id,param) \
    ceu_out_go(app,id,param)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#ifdef __ANDROID__
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
    };

    /* IN__STK */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        u8        stk;
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif
} tceu_trl;

/* TCEU_EVTP */

typedef union tceu_evtp {
    int   v;
    float f;
    void* ptr;
    s32   dt;
#ifdef CEU_THREADS
    CEU_THREADS_T thread;
#endif
#ifdef __cplusplus
    tceu_evtp () {}
    tceu_evtp (float vv) : float(vv) {}
    tceu_evtp (void* vv) : ptr(vv)   {}
    tceu_evtp (s32   vv) : dt(vv)    {}
    /*tceu_evtp (int   vv) : v(vv)   {}*/
#endif
} tceu_evtp;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    tceu_evtp evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    void*     evto;
#endif
#endif
    tceu_nevt evt;
} tceu_stk;

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS
#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Two purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             */
#ifdef CEU_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
    struct tceu_org* nxt_free;  /* "to free" list (only on reaction end) */
#endif
#endif  /* CEU_ORGS */

#ifdef CEU_NEWS_POOL
    void*  pool;            /* TODO(ram): opt, traverse lst of cls pools */
#endif

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_GO */

typedef struct tceu_go {
    int         evt;
    tceu_evtp   evtp;

#ifdef CEU_INTS
#ifdef CEU_ORGS
    tceu_org* evto;       /* org that emitted current event */
#endif
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
#ifdef __AVR
    #define CEU_MAX_STACK   32
#else
    #define CEU_MAX_STACK   32768
#endif
    /* TODO: CEU_ORGS is calculable // CEU_NEWS isn't (255?) */
    tceu_stk stk[CEU_MAX_STACK];
#else
    tceu_stk stk[CEU_NTRAILS];
#endif

    /* current traversal state */
    int        stki;   /* points to next */
    tceu_trl*  trl;
    tceu_nlbl  lbl;
    tceu_org* org;

    /* traversals may be bounded to org/trl
     * default (NULL) is to traverse everything */
#ifdef CEU_CLEAR
    void* stop;     /* stop at this trl/org */
#endif
} tceu_go;

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:         2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_RET
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min;
    s32         wclk_min_tmp;
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_;
    s32         wclk_min_tmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#ifdef CEU_LUA
    lua_State*  lua;
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    tceu_evtp   (*calls) (struct tceu_app*,tceu_nevt,tceu_evtp);
    void**      sys_vec;
    void*       addr;
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* RET_* */

enum {
    RET_HALT = 0,
    RET_END
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_ORGS)
    , RET_ORG
#endif
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_TRL
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, tceu_evtp evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
    tceu_evtp param;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void*     ceu_sys_malloc    (size_t size);
void      ceu_sys_free      (void* ptr);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
int       ceu_sys_clear     (tceu_go* go, int start, void* stop);
void      ceu_sys_org       (tceu_org* org, int n, int lbl, int seqno, int isDyn, tceu_org* par_org, int par_trl);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, tceu_evtp param, int sz, byte* buf);
tceu_evtp ceu_sys_call      (tceu_app* app, tceu_nevt evt, tceu_evtp param);

enum {
    CEU_SYS_MALLOC = 0,
    CEU_SYS_FREE,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
    CEU_SYS_CLEAR,
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


#define CEU_IN__NONE 0
#define CEU_IN__STK 255
#define CEU_IN__ORG 254
#define CEU_IN__ORG_PSED 253
#define CEU_IN__INIT 252
#define CEU_IN__CLEAR 251
#define CEU_IN__WCLOCK 250
#define CEU_IN__ASYNC 249
#define CEU_IN__THREAD 248
#define CEU_IN_REMOTE_WORKER_DONE 247
#define CEU_IN_USER_TASK 246
#define CEU_OUT_n 0
      /* CEU_IN_, CEU_OUT_ */
#define CEU_FUN_printf
#define CEU_FUN_init
#define CEU_FUN_pop
#define CEU_FUN_empty
#define CEU_FUN_push
   /* CEU_FUN_ */


/* class definitions */
/*
// TODO: host language to have access to classes
=== CLSS_DEFS ===
*/

#endif

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#if defined(CEU_OS) && defined(__AVR)
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#ifdef __cplusplus
#define CEU_EVTP(v) (tceu_evtp(v))
#else
#define CEU_EVTP(v) ((tceu_evtp)v)
#endif

#ifdef CEU_OS
    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    #define CEU_PSES
    #define CEU_NEWS
    #define CEU_NEWS_MALLOC
    #define CEU_NEWS_POOL
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__INIT        252
    #define CEU_IN__CLEAR       251
    #define CEU_IN__WCLOCK      250
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              244
#endif

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

    #define ceu_out_malloc(size) \
        ((__typeof__(ceu_sys_malloc)*)((_ceu_app)->sys_vec[CEU_SYS_MALLOC]))(size)
    #define ceu_out_free(ptr) \
        ((__typeof__(ceu_sys_free)*)((_ceu_app)->sys_vec[CEU_SYS_FREE]))(ptr)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_clear(go,start,stop) \
        ((__typeof__(ceu_sys_clear)*)((_ceu_app)->sys_vec[CEU_SYS_CLEAR]))(go,start,stop)

    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,seqno,isDyn,par_org,par_trl)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_SPAWN]))(go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit_buf(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,CEU_EVTP((void*)NULL),sz,buf)

    #define ceu_out_emit_val(app,id,param) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,param,0,NULL)

    #define ceu_out_call_val(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS */
    #define ceu_out_malloc(size) \
            ceu_sys_malloc(size)
    #define ceu_out_free(ptr) \
            ceu_sys_free(ptr)
    #define ceu_out_req() \
            ceu_sys_req()
#ifdef CEU_CLEAR
    #define ceu_out_clear(go,start,stop) \
            ceu_sys_clear(go,start,stop)
#endif
#ifdef CEU_NEWS
    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,isDyn,par_org,par_trl)
#else
    #define ceu_out_org(app,org,n,lbl,seqno,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,par_org,par_trl)
#endif
#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(go, lbl_cnt, org, lbl_org)
#endif
/*#ifdef ceu_out_emit_val*/
    #define ceu_out_emit_buf(app,id,sz,buf) \
            ceu_out_emit_val(app,id,CEU_EVTP((void*)buf))
/*#endif*/
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
#endif

#define ceu_in_emit_val(app,id,param) \
    ceu_out_go(app,id,param)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#ifdef __ANDROID__
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
    };

    /* IN__STK */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        u8        stk;
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif
} tceu_trl;

/* TCEU_EVTP */

typedef union tceu_evtp {
    int   v;
    float f;
    void* ptr;
    s32   dt;
#ifdef CEU_THREADS
    CEU_THREADS_T thread;
#endif
#ifdef __cplusplus
    tceu_evtp () {}
    tceu_evtp (float vv) : float(vv) {}
    tceu_evtp (void* vv) : ptr(vv)   {}
    tceu_evtp (s32   vv) : dt(vv)    {}
    /*tceu_evtp (int   vv) : v(vv)   {}*/
#endif
} tceu_evtp;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    tceu_evtp evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    void*     evto;
#endif
#endif
    tceu_nevt evt;
} tceu_stk;

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS
#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Two purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             */
#ifdef CEU_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
    struct tceu_org* nxt_free;  /* "to free" list (only on reaction end) */
#endif
#endif  /* CEU_ORGS */

#ifdef CEU_NEWS_POOL
    void*  pool;            /* TODO(ram): opt, traverse lst of cls pools */
#endif

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_GO */

typedef struct tceu_go {
    int         evt;
    tceu_evtp   evtp;

#ifdef CEU_INTS
#ifdef CEU_ORGS
    tceu_org* evto;       /* org that emitted current event */
#endif
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
#ifdef __AVR
    #define CEU_MAX_STACK   32
#else
    #define CEU_MAX_STACK   32768
#endif
    /* TODO: CEU_ORGS is calculable // CEU_NEWS isn't (255?) */
    tceu_stk stk[CEU_MAX_STACK];
#else
    tceu_stk stk[CEU_NTRAILS];
#endif

    /* current traversal state */
    int        stki;   /* points to next */
    tceu_trl*  trl;
    tceu_nlbl  lbl;
    tceu_org* org;

    /* traversals may be bounded to org/trl
     * default (NULL) is to traverse everything */
#ifdef CEU_CLEAR
    void* stop;     /* stop at this trl/org */
#endif
} tceu_go;

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:         2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_RET
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min;
    s32         wclk_min_tmp;
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_;
    s32         wclk_min_tmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#ifdef CEU_LUA
    lua_State*  lua;
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    tceu_evtp   (*calls) (struct tceu_app*,tceu_nevt,tceu_evtp);
    void**      sys_vec;
    void*       addr;
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* RET_* */

enum {
    RET_HALT = 0,
    RET_END
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_ORGS)
    , RET_ORG
#endif
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_TRL
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, tceu_evtp evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
    tceu_evtp param;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void*     ceu_sys_malloc    (size_t size);
void      ceu_sys_free      (void* ptr);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
int       ceu_sys_clear     (tceu_go* go, int start, void* stop);
void      ceu_sys_org       (tceu_org* org, int n, int lbl, int seqno, int isDyn, tceu_org* par_org, int par_trl);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, tceu_evtp param, int sz, byte* buf);
tceu_evtp ceu_sys_call      (tceu_app* app, tceu_nevt evt, tceu_evtp param);

enum {
    CEU_SYS_MALLOC = 0,
    CEU_SYS_FREE,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
    CEU_SYS_CLEAR,
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */

/* TODO: #ifdef CEU_INTS: seqno, stki, CEU_STK */

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#if defined(CEU_OS) && defined(__AVR)
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#ifdef __cplusplus
#define CEU_EVTP(v) (tceu_evtp(v))
#else
#define CEU_EVTP(v) ((tceu_evtp)v)
#endif

#ifdef CEU_OS
    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    #define CEU_PSES
    #define CEU_NEWS
    #define CEU_NEWS_MALLOC
    #define CEU_NEWS_POOL
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__INIT        252
    #define CEU_IN__CLEAR       251
    #define CEU_IN__WCLOCK      250
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              244
#endif

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

    #define ceu_out_malloc(size) \
        ((__typeof__(ceu_sys_malloc)*)((_ceu_app)->sys_vec[CEU_SYS_MALLOC]))(size)
    #define ceu_out_free(ptr) \
        ((__typeof__(ceu_sys_free)*)((_ceu_app)->sys_vec[CEU_SYS_FREE]))(ptr)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_clear(go,start,stop) \
        ((__typeof__(ceu_sys_clear)*)((_ceu_app)->sys_vec[CEU_SYS_CLEAR]))(go,start,stop)

    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,seqno,isDyn,par_org,par_trl)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_SPAWN]))(go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit_buf(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,CEU_EVTP((void*)NULL),sz,buf)

    #define ceu_out_emit_val(app,id,param) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,param,0,NULL)

    #define ceu_out_call_val(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS */
    #define ceu_out_malloc(size) \
            ceu_sys_malloc(size)
    #define ceu_out_free(ptr) \
            ceu_sys_free(ptr)
    #define ceu_out_req() \
            ceu_sys_req()
#ifdef CEU_CLEAR
    #define ceu_out_clear(go,start,stop) \
            ceu_sys_clear(go,start,stop)
#endif
#ifdef CEU_NEWS
    #define ceu_out_org(app,org,n,lbl,seqno,isDyn,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,isDyn,par_org,par_trl)
#else
    #define ceu_out_org(app,org,n,lbl,seqno,par_org,par_trl) \
            ceu_sys_org(org,n,lbl,seqno,par_org,par_trl)
#endif
#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(go, lbl_cnt, org, lbl_org)
#endif
/*#ifdef ceu_out_emit_val*/
    #define ceu_out_emit_buf(app,id,sz,buf) \
            ceu_out_emit_val(app,id,CEU_EVTP((void*)buf))
/*#endif*/
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
#endif

#define ceu_in_emit_val(app,id,param) \
    ceu_out_go(app,id,param)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#ifdef __ANDROID__
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
    };

    /* IN__STK */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        u8        stk;
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif
} tceu_trl;

/* TCEU_EVTP */

typedef union tceu_evtp {
    int   v;
    float f;
    void* ptr;
    s32   dt;
#ifdef CEU_THREADS
    CEU_THREADS_T thread;
#endif
#ifdef __cplusplus
    tceu_evtp () {}
    tceu_evtp (float vv) : float(vv) {}
    tceu_evtp (void* vv) : ptr(vv)   {}
    tceu_evtp (s32   vv) : dt(vv)    {}
    /*tceu_evtp (int   vv) : v(vv)   {}*/
#endif
} tceu_evtp;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    tceu_evtp evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    void*     evto;
#endif
#endif
    tceu_nevt evt;
} tceu_stk;

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS
#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Two purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             */
#ifdef CEU_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
    struct tceu_org* nxt_free;  /* "to free" list (only on reaction end) */
#endif
#endif  /* CEU_ORGS */

#ifdef CEU_NEWS_POOL
    void*  pool;            /* TODO(ram): opt, traverse lst of cls pools */
#endif

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_GO */

typedef struct tceu_go {
    int         evt;
    tceu_evtp   evtp;

#ifdef CEU_INTS
#ifdef CEU_ORGS
    tceu_org* evto;       /* org that emitted current event */
#endif
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
#ifdef __AVR
    #define CEU_MAX_STACK   32
#else
    #define CEU_MAX_STACK   32768
#endif
    /* TODO: CEU_ORGS is calculable // CEU_NEWS isn't (255?) */
    tceu_stk stk[CEU_MAX_STACK];
#else
    tceu_stk stk[CEU_NTRAILS];
#endif

    /* current traversal state */
    int        stki;   /* points to next */
    tceu_trl*  trl;
    tceu_nlbl  lbl;
    tceu_org* org;

    /* traversals may be bounded to org/trl
     * default (NULL) is to traverse everything */
#ifdef CEU_CLEAR
    void* stop;     /* stop at this trl/org */
#endif
} tceu_go;

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:         2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_RET
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min;
    s32         wclk_min_tmp;
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_;
    s32         wclk_min_tmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#ifdef CEU_LUA
    lua_State*  lua;
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    tceu_evtp   (*calls) (struct tceu_app*,tceu_nevt,tceu_evtp);
    void**      sys_vec;
    void*       addr;
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* RET_* */

enum {
    RET_HALT = 0,
    RET_END
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_ORGS)
    , RET_ORG
#endif
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_TRL
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, tceu_evtp evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
    tceu_evtp param;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void*     ceu_sys_malloc    (size_t size);
void      ceu_sys_free      (void* ptr);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
int       ceu_sys_clear     (tceu_go* go, int start, void* stop);
void      ceu_sys_org       (tceu_org* org, int n, int lbl, int seqno, int isDyn, tceu_org* par_org, int par_trl);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, tceu_evtp param, int sz, byte* buf);
tceu_evtp ceu_sys_call      (tceu_app* app, tceu_nevt evt, tceu_evtp param);

enum {
    CEU_SYS_MALLOC = 0,
    CEU_SYS_FREE,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
    CEU_SYS_CLEAR,
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


#ifdef CEU_OS
#ifdef __AVR
#include <avr/pgmspace.h>
void* CEU_APP_ADDR = NULL;
#endif
#endif

#include <string.h>

#ifdef CEU_DEBUG
#include <stdio.h>      /* fprintf */
#include <assert.h>
#endif

#if defined(CEU_DEBUG) || defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS)
#include <stdlib.h>     /* malloc/free, exit */
#endif

#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

typedef struct {
    int     size;
    int     free;
    int     index;
    int     unit;
    byte**  queue;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type* name##_queue[size];          \
    type  name##_mem[size];            \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit,
                    byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit,
                    byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

/*
 * pthread_t thread;
 * pthread_mutex_t mutex;
 * pthread_cond_t  cond;
 * pthread_self();
        Uint32 SDL_ThreadID(void);
 * pthread_create(&thread, NULL, f, &p);
        SDL_Thread *SDL_CreateThread(int (*fn)(void *), void *data);
 * pthread_mutex_lock(&mutex);
 * pthread_mutex_unlock(&mutex);
 * pthread_cond_wait(&cond, &mutex);
 * pthread_cond_signal(&cond);
*/

/**********************************************************************/

#ifdef CEU_LUA
int ceu_lua_atpanic (lua_State* lua) {
#ifdef CEU_DEBUG
    fprintf(stderr, "LUA_ATPANIC: %s\n",
            lua_tostring(lua,-1));
#endif
    return 0;
}
#endif

/**********************************************************************/

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
#define CEU_MAX_DYNS 100
static int _ceu_dyns_ = 0;  /* check if total of alloc/free match */
#endif
#endif

#if defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS)
void* ceu_sys_malloc (size_t size) {
#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    if (_ceu_dyns_ >= CEU_MAX_DYNS)
        return NULL;
    _ceu_dyns_++;           /* assumes no malloc fails */
#endif
#endif
    return malloc(size);
}

void ceu_sys_free (void* ptr) {
#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    if (ptr != NULL)
        _ceu_dyns_--;
#endif
#endif
    free(ptr);
}
#endif

/**********************************************************************/

/* TODO: ifndef CEU_OS? */
int CEU_REQS = 0;
int ceu_sys_req (void) {
    CEU_REQS++;
    return CEU_REQS;
}

/**********************************************************************/

/* TODO: CEU_OS */
#ifdef CEU_ORGS

void ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk) {
    org->trls[idx].evt  = CEU_IN__ORG;
    org->trls[idx].lnks = lnk;
    lnk[0].nxt = (tceu_org*) &lnk[1];
    lnk[1].prv = (tceu_org*) &lnk[0];
    lnk[1].nxt =  org;
    lnk[1].n   =  0;    /* marks end of linked list */
    lnk[1].lnk =  idx+1;
}

int ceu_sys_org_spawn (tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org) {
    /* hold current blk trail: set to my continuation */
    _ceu_go->trl->evt = CEU_IN__STK;
    _ceu_go->trl->lbl = lbl_cnt;
    _ceu_go->trl->stk = _ceu_go->stki;

    _ceu_go->stk[_ceu_go->stki  ].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    _ceu_go->stk[_ceu_go->stki  ].evto = _ceu_go->evto;
#endif
#endif
    _ceu_go->stk[_ceu_go->stki++].evt  = _ceu_go->evt;

    /* switch to ORG */

    org->trls[0].evt = CEU_IN__STK;
    org->trls[0].lbl = lbl_org;
    org->trls[0].stk = _ceu_go->stki;

    _ceu_go->org  = org;
#ifdef CEU_CLEAR
    _ceu_go->stop = &_ceu_go->org->trls[_ceu_go->org->n]; /* don't follow the up link */
#endif
    return RET_ORG;
}

#endif

void ceu_sys_org (tceu_org* org, int n, int lbl, int seqno,
#ifdef CEU_NEWS
                  int isDyn,
#endif
                  tceu_org* par_org, int par_trl)
{
    /* { evt=0, seqno=0, lbl=0 } for all trails */
    memset(&org->trls, 0, n*sizeof(tceu_trl));

#if defined(CEU_ORGS) || defined(CEU_OS)
    org->n = n;
    org->isAlive = 1;
#endif
#ifdef CEU_NEWS
    org->isDyn = isDyn;
#endif

    /* org.trls[0] == org.blk.trails[1] */
    org->trls[0].evt   = CEU_IN__STK;
    org->trls[0].lbl   = lbl;
    org->trls[0].seqno = seqno;

#ifdef CEU_ORGS
    if (par_org == NULL) {
        return;             /* main class */
    }

    /* re-link */
    {
        tceu_org_lnk* lst = &par_org->trls[par_trl].lnks[1];
        lst->prv->nxt = org;
        org->prv = lst->prv;
        org->nxt = (tceu_org*)lst;
        lst->prv = org;
    }
#endif  /* CEU_ORGS */
}
#ifndef CEU_ORGS
#define ceu_sys_org(a,b,c,d,e,f) ceu_sys_org(a,b,c,d,NULL,0)
#endif

/**********************************************************************/

#ifdef CEU_WCLOCKS

/* TODO: wclk_min_tmp to be global among all apps */

int ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* track expiring time to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if (t>app->wclk_min_tmp || t>dt) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    if (app->wclk_min > t) {
        app->wclk_min = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}

#ifdef CEU_TIMEMACHINE
/* TODO: unify with above */
int ceu_sys_wclock_ (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* track expiring time to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late_;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if (t>app->wclk_min_tmp_ || t>dt) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    if (app->wclk_min_ > t) {
        app->wclk_min_ = t;
#ifdef ceu_out_wclock_set_
        ceu_out_wclock_set_(t);
#endif
    }

    return ret;
}
#endif

#endif

/**********************************************************************/

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed) {
    do {
        if (psed) {
            if (trl->evt == CEU_IN__ORG)
                trl->evt = CEU_IN__ORG_PSED;
        } else {
            if (trl->evt == CEU_IN__ORG_PSED)
                trl->evt = CEU_IN__ORG;
        }
        if ( trl->evt == CEU_IN__ORG
        ||   trl->evt == CEU_IN__ORG_PSED ) {
            trl += 2;       /* jump [fst|lst] */
        }
    } while (++trl <= trlF);

#ifdef ceu_out_wclock_set
    if (!psed) {
        ceu_out_wclock_set(0);  /* TODO: recalculate MIN clock */
                                /*       between trl => trlF   */
    }
#endif
#ifdef CEU_TIMEMACHINE
#ifdef ceu_out_wclock_set_
    if (!psed) {
        ceu_out_wclock_set_(0);  /* TODO: recalculate MIN clock */
                                 /*       between trl => trlF   */
    }
#endif
#endif
}
#endif

/**********************************************************************/

#ifdef CEU_CLEAR
/* TODO: CEU_OS map (ceu_out_* )*/
int ceu_sys_clear (tceu_go* go, int start, void* stop) {
    go->stk[go->stki  ].evtp = go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    go->stk[go->stki  ].evto = go->evto;
#endif
#endif
    go->stk[go->stki++].evt  = go->evt;
    go->trl  = &go->org->trls[start];
    go->stop = stop;
    go->evt = CEU_IN__CLEAR;
    return RET_TRL;
}
#endif

/* TODO: ifndef CEU_OS? */
u8 CEU_GC = 0;  /* execute __ceu_os_gc() when "true" */

void ceu_sys_go (tceu_app* app, int evt, tceu_evtp evtp)
{
    tceu_go go;

    switch (evt) {
#ifdef CEU_ASYNCS
        case CEU_IN__ASYNC:
            app->pendingAsyncs = 0;
            break;
#endif
#ifdef CEU_WCLOCKS
        case CEU_IN__WCLOCK:
            if (app->wclk_min <= evtp.dt) {
                app->wclk_late = evtp.dt - app->wclk_min;
            }
            app->wclk_min_tmp = app->wclk_min;
            app->wclk_min     = CEU_WCLOCK_INACTIVE;
            break;
#ifdef CEU_TIMEMACHINE
        case CEU_IN__WCLOCK_:
            if (app->wclk_min_ <= evtp.dt) {
                app->wclk_late_ = evtp.dt - app->wclk_min_;
            }
            app->wclk_min_tmp_ = app->wclk_min_;
            app->wclk_min_     = CEU_WCLOCK_INACTIVE;
            break;
#endif
#endif
    }

    go.evt  = evt;
    go.evtp = evtp;
    go.stki = 0;
#ifdef CEU_CLEAR
    go.stop = NULL;     /* traverse all (don't stop) */
#endif

#ifdef CEU_NEWS
    tceu_org* lst_free = NULL;  /* "to free" list (only on reaction end) */
#endif

    app->seqno++;

    for (;;)    /* STACK */
    {
#ifdef CEU_DEBUG
        assert(go.stki < 32000);
#endif
        /* TODO: don't restart if kill is impossible (hold trl on stk) */
        go.org = app->data;    /* on pop(), always restart */
#if defined(CEU_INTS) || defined(CEU_ORGS)
_CEU_GO_CALL_ORG_:
#endif
        /* restart from org->trls[0] */
        go.trl = &go.org->trls[0];

#if defined(CEU_CLEAR) || defined(CEU_ORGS)
_CEU_GO_CALL_TRL_:  /* restart from org->trls[i] */
#endif

#ifdef CEU_DEBUG_TRAILS
#if defined(CEU_ORGS) || defined(CEU_OS)
fprintf(stderr, "GO[%d]: evt=%d stk=%d org=%p [%d/%p]\n", app->seqno,
                go.evt, go.stki, go.org, go.org->n, go.org->trls);
#else
fprintf(stderr, "GO[%d]: evt=%d stk=%d [%d]\n", app->seqno,
                go.evt, go.stki, CEU_NTRAILS);
#endif
#endif

        for (;;) /* TRL // TODO(speed): only range of trails that apply */
        {        /* (e.g. events that do not escape an org) */
#ifdef CEU_CLEAR
            if (go.trl == go.stop) {    /* bounded trail traversal? */
                go.stop = NULL;           /* back to default */
                break;                      /* pop stack */
            }
#endif

            /* go.org has been traversed to the end? */
            if (go.trl ==
                &go.org->trls[
#if defined(CEU_ORGS) || defined(CEU_OS)
                    go.org->n
#else
                    CEU_NTRAILS
#endif
                ])
            {
                if (go.org == app->data) {
                    break;  /* pop stack */
                }

#ifdef CEU_ORGS
                {
                    /* hold next org/trl */
                    /* TODO(speed): jump LST */
                    tceu_org* _org = go.org->nxt;
                    tceu_trl* _trl = &_org->trls [
                                        (go.org->n == 0) ?
                                         ((tceu_org_lnk*)go.org)->lnk : 0
                                      ];

                    /* org has been traversed and *CLEARED* to the end? */
                    if (go.evt == CEU_IN__CLEAR) {

#ifdef CEU_ORGS_WATCHING
                        /* TODO: stack will overflow!!! T[9999] */
                        /* emit this.ok */
                        /*go.stk[go.stki].evtp = ?*/
                        go.stk[go.stki].evto = go.org;
                        go.stk[go.stki].evt  = 1;   /* TODO: 1==_ok */
                        go.stki++;
#endif

#ifdef CEU_NEWS
                        if ( go.org->n != 0 /* TODO: avoids LNKs (must be before isDyn */
                        &&   go.org->isDyn ) {
                            /* re-link PRV <-> NXT */
                            go.org->prv->nxt = go.org->nxt;
                            go.org->nxt->prv = go.org->prv;

                            /* Should be freed if (malloc'ed) or
                             *                    (pool still on scope):
                             * - malloc'ed:     (org->pool==NULL)
                             * - pool on scope: (!org->isAlive)
                             */
/* TODO: what if both happens at the same time (body and pool terminate?) */
#ifdef CEU_NEWS_POOL
                            if (!go.org->isAlive
#ifdef CEU_NEWS_MALLOC
                            || go.org->pool == NULL
#endif
                            )
#else
                            /* malloc'ed for sure, no if required */
#endif
                            {
                                tceu_org* nxt = lst_free;
                                go.org->nxt_free = NULL;    /* no next element */
                                if (lst_free == NULL) {
                                    lst_free = go.org;      /* new first element */
                                } else {
                                    while (nxt->nxt_free != NULL) {
                                        nxt = nxt->nxt_free; /* find last element */
                                    }
                                    nxt->nxt_free = go.org;  /* put after that */
                                }
                            }
                            go.org->isAlive = 0;

                            /* explicit free(me) or end of spawn */
                            if (go.stop == go.org)
                                break;  /* pop stack */
                        }
#else
                        go.org->isAlive = 0;
#endif  /* CEU_NEWS */
                    }

                    go.org = _org;
                    go.trl = _trl;
/*fprintf(stderr, "UP[%p] %p %p\n", trl+1, go.org go.trl);*/
                    goto _CEU_GO_CALL_TRL_;
                }
#endif  /* CEU_ORGS */
            }

            /* continue traversing CUR org */
            {
#ifdef CEU_DEBUG_TRAILS
#ifdef CEU_ORGS
if (go.trl->evt==CEU_IN__ORG)
    fprintf(stderr, "\tTRY [%p] : evt=%d org=%p->%p\n",
                    go.trl, go.trl->evt,
                    &go.trl->lnks[0], &go.trl->lnks[1]);
else
#endif
    fprintf(stderr, "\tTRY [%p] : evt=%d seqno=%d lbl=%d\n",
                    go.trl, go.trl->evt, go.trl->seqno, go.trl->lbl);
#endif

                /* jump into linked orgs */
#ifdef CEU_ORGS
                if ( (go.trl->evt == CEU_IN__ORG)
#ifdef CEU_PSES
                  || (go.trl->evt==CEU_IN__ORG_PSED && go.evt==CEU_IN__CLEAR)
#endif
                   )
                {
                    /* TODO(speed): jump LST */
                    go.org = go.trl->lnks[0].nxt;   /* jump FST */
                    if (go.evt == CEU_IN__CLEAR) {
                        go.trl->evt = CEU_IN__NONE;
                    }
                    goto _CEU_GO_CALL_ORG_;
                }
#endif /* CEU_ORGS */

                switch (go.evt)
                {
                    /* "clear" event */
                    case CEU_IN__CLEAR:
                        if (go.trl->evt == CEU_IN__CLEAR)
                            goto _CEU_GO_GO_;
                        go.trl->evt = CEU_IN__NONE;
                        goto _CEU_GO_NEXT_;
                }

                /* a continuation (STK) will always appear before a
                 * matched event in the same stack level
                 */
                if ( ! (
                    (go.trl->evt==CEU_IN__STK && go.trl->stk==go.stki)
                ||
                    (go.trl->evt==go.evt && go.trl->seqno!=app->seqno)
                    /* evt!=CEU_IN__STK (never generated): comp is safe */
                    /* we use `!=Â´ intead of `<Â´ due to u8 overflow */
                ) ) {
                    goto _CEU_GO_NEXT_;
                }
_CEU_GO_GO_:
                /* execute this trail */
                go.trl->evt   = CEU_IN__NONE;
                go.trl->seqno = app->seqno;   /* don't awake again */
                go.lbl = go.trl->lbl;
            }

            {
#if defined(CEU_OS) && defined(__AVR)
                CEU_APP_ADDR = app->addr;
#endif
                /*** CODE ***/
                int _ret = app->code(app, &go);
#if defined(CEU_OS) && defined(__AVR)
                CEU_APP_ADDR = 0;
#endif

                switch (_ret) {
                    case RET_END:
#if defined(CEU_RET) || defined(CEU_OS)
                        app->isAlive = 0;
                        CEU_GC = 1;
#endif
                        goto _CEU_GO_QUIT_;
/*
                    case RET_GOTO:
                        goto _CEU_GOTO_;
*/
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
                    case RET_TRL:
                        goto _CEU_GO_CALL_TRL_;
#endif
#if defined(CEU_INTS) || defined(CEU_ORGS)
                    case RET_ORG:
                        goto _CEU_GO_CALL_ORG_;
#endif
#ifdef CEU_ASYNCS
                    case RET_ASYNC:
#ifdef ceu_out_async
                        ceu_out_async(app);
#endif
                        app->pendingAsyncs = 1;
                        break;
#endif
                    default:
                        break;
                }
            }
_CEU_GO_NEXT_:
            /* go.trl!=CEU_IN__ORG guaranteed here */
            if (go.trl->evt!=CEU_IN__STK && go.trl->seqno!=app->seqno)
                go.trl->seqno = app->seqno-1;   /* keeps the gap tight */
            go.trl++;
        }

        if (go.stki == 0) {
            break;      /* reaction has terminated */
        }
        go.evtp = go.stk[--go.stki].evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
        go.evto = (tceu_org*) go.stk[  go.stki].evto;
#endif
#endif
        go.evt  = go.stk[  go.stki].evt;
    }

_CEU_GO_QUIT_:;

#ifdef CEU_WCLOCKS
    if (evt==CEU_IN__WCLOCK) {
/*
#ifdef ceu_out_wclock_set
        if (app->wclk_min != CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(app->wclk_min);   // only signal after all
            ;
        }
#endif
*/
        app->wclk_late = 0;
    }
#ifdef CEU_TIMEMACHINE
    if (evt==CEU_IN__WCLOCK_) {
/*
#ifdef ceu_out_wclock_set
        if (app->wclk_min_ != CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(app->wclk_min_);   // only signal after all
            ;
        }
#endif
*/
        app->wclk_late_ = 0;
    }
#endif
#endif

    /* free all orgs on "lst_free" on reaction termination */
#ifdef CEU_NEWS
    while (lst_free != NULL) {
        tceu_org* org = lst_free;
        lst_free = org->nxt_free;
#if    defined(CEU_NEWS_POOL) && !defined(CEU_NEWS_MALLOC)
        ceu_pool_free((tceu_pool*)org->pool, (byte*)org);
#elif  defined(CEU_NEWS_POOL) &&  defined(CEU_NEWS_MALLOC)
        if (org->pool == NULL)
            ceu_sys_free(org);
        else
            ceu_pool_free((tceu_pool*)org->pool, (byte*)org);
#elif !defined(CEU_NEWS_POOL) &&  defined(CEU_NEWS_MALLOC)
        ceu_sys_free(org);
#endif
    }
#endif
}

int ceu_go_all (tceu_app* app)
{
    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    app->init(app);     /* calls CEU_THREADS_MUTEX_LOCK() */

#ifdef CEU_IN_OS_START
#if defined(CEU_RET) || defined(CEU_OS)
    if (app->isAlive)
#endif
        ceu_sys_go(app, CEU_IN_OS_START, CEU_EVTP((void*)NULL));
#endif

#ifdef CEU_ASYNCS
    while(
#if defined(CEU_RET) || defined(CEU_OS)
            app->isAlive &&
#endif
            (
#ifdef CEU_THREADS
                app->threads_n>0 ||
#endif
                app->pendingAsyncs
            ) )
    {
        ceu_sys_go(app, CEU_IN__ASYNC, CEU_EVTP((void*)NULL));
#ifdef CEU_THREADS
        CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
        /* allow threads to also execute */
        CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif
    }
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
#endif

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    assert(_ceu_dyns_ == 0);
#endif
#endif

#ifdef CEU_RET
    return app->ret;
#else
    return 0;
#endif
}

#ifdef CEU_OS

/* SYS_VECTOR
 */
void* CEU_SYS_VEC[CEU_SYS_MAX] __attribute__((used)) = {
    (void*) &ceu_sys_malloc,
    (void*) &ceu_sys_free,
    (void*) &ceu_sys_req,
    (void*) &ceu_sys_load,
#ifdef CEU_ISR
    (void*) &ceu_sys_isr,
#endif
    (void*) &ceu_sys_clear,
    (void*) &ceu_sys_org,
#ifdef CEU_ORGS
    (void*) &ceu_sys_org_trail,
    (void*) &ceu_sys_org_spawn,
#endif
    (void*) &ceu_sys_start,
    (void*) &ceu_sys_link,
    (void*) &ceu_sys_unlink,
    (void*) &ceu_sys_emit,
    (void*) &ceu_sys_call,
#ifdef CEU_WCLOCKS
    (void*) &ceu_sys_wclock,
#endif
    (void*) &ceu_sys_go
};

/*****************************************************************************
 * QUEUE
 * - 256 avoids doing modulo operations
 * - n: number of entries
 * - 0: next position to consume
 * - i: next position to enqueue
 */
#if CEU_QUEUE_MAX == 256
    byte QUEUE[CEU_QUEUE_MAX] = {0};    /* {0} avoids .bss */
    int  QUEUE_tot = 0;
    u8   QUEUE_get = 0;
    u8   QUEUE_put = 0;
#else
    byte QUEUE[CEU_QUEUE_MAX] = {0};    /* {0} avoids .bss */
    int  QUEUE_tot = 0;
    u16  QUEUE_get = 0;
    u16  QUEUE_put = 0;
#endif

tceu_queue* ceu_sys_queue_get (void) {
    tceu_queue* ret;
    CEU_ISR_OFF();
    if (QUEUE_tot == 0) {
        ret = NULL;
    } else {
#ifdef CEU_DEBUG
        assert(QUEUE_tot > 0);
#endif
        ret = (tceu_queue*) &QUEUE[QUEUE_get];
    }
    CEU_ISR_ON();
    return ret;
}

int ceu_sys_queue_put (tceu_app* app, tceu_nevt evt, tceu_evtp param,
                       int sz, byte* buf) {
    CEU_ISR_OFF();

    int n = sizeof(tceu_queue) + sz;

    if (QUEUE_tot+n > CEU_QUEUE_MAX)
        return 0;   /* TODO: add event FULL when CEU_QUEUE_MAX-1 */

    /* An event+data must be continuous in the QUEUE. */
    if (QUEUE_put+n+sizeof(tceu_queue)>=CEU_QUEUE_MAX && evt!=CEU_IN__NONE) {
        int fill = CEU_QUEUE_MAX - QUEUE_put - sizeof(tceu_queue);
        /*_ceu_sys_emit(app, CEU_IN__NONE, param, fill, NULL);*/
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = CEU_IN__NONE;
        qu->sz  = fill;
        QUEUE_put += sizeof(tceu_queue) + fill;
        QUEUE_tot += sizeof(tceu_queue) + fill;
    }

    {
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = evt;
        qu->sz  = sz;

        if (sz == 0) {
            /* "param" is self-contained */
            qu->param = param;
        } else {
            /* "param" points to "buf" */
            qu->param.ptr = qu->buf;
            memcpy(qu->buf, buf, sz);
        }
    }
    QUEUE_put += n;
    QUEUE_tot += n;

    CEU_ISR_ON();
    return 1;
}

void ceu_sys_queue_rem (void) {
    CEU_ISR_OFF();
    tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get];
    QUEUE_tot -= sizeof(tceu_queue) + qu->sz;
    QUEUE_get += sizeof(tceu_queue) + qu->sz;
    CEU_ISR_ON();
}

/*****************************************************************************/

static tceu_app* CEU_APPS = NULL;
static tceu_lnk* CEU_LNKS = NULL;

#ifdef CEU_RET
    int ok  = 0;
    int ret = 0;
#endif

/* TODO: remove this */
int ceu_sys_emit (tceu_app* app, tceu_nevt evt, tceu_evtp param,
                  int sz, byte* buf) {
    return ceu_sys_queue_put(app, evt, param, sz, buf);
}

tceu_evtp ceu_sys_call (tceu_app* app, tceu_nevt evt, tceu_evtp param) {
    tceu_lnk* lnk = CEU_LNKS;
    for (; lnk; lnk=lnk->nxt)
    {
        if (app!=lnk->src_app || evt!=lnk->src_evt)
            continue;
#if defined(CEU_OS) && defined(__AVR)
        void* __old = CEU_APP_ADDR; /* must remember to resume after call */
        CEU_APP_ADDR = lnk->dst_app->addr;
#endif
        tceu_evtp ret = lnk->dst_app->calls(lnk->dst_app, lnk->dst_evt, param);
#if defined(CEU_OS) && defined(__AVR)
        CEU_APP_ADDR = __old;
#endif
        return ret;
    }
/* TODO: error? */
    return CEU_EVTP((void*)NULL);
}

static void _ceu_sys_unlink (tceu_lnk* lnk) {
    /* remove as head */
    if (CEU_LNKS == lnk) {
        CEU_LNKS = lnk->nxt;
/* TODO: prv */
    /* remove in the middle */
    } else {
        tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt!=NULL && cur->nxt!=lnk)
			cur = cur->nxt;
		if (cur->nxt != NULL)
            cur->nxt = lnk->nxt;
	}

    /*lnk->nxt = NULL;*/
    ceu_sys_free(lnk);
}

static void __ceu_os_gc (void)
{
    if (! CEU_GC) return;
    CEU_GC = 0;

    /* remove pending events */
    {
        CEU_ISR_OFF();
        int i = 0;
        while (i < QUEUE_tot) {
            tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get+i];
            if (qu->app!=NULL && !qu->app->isAlive) {
                qu->evt = CEU_IN__NONE;
            }
            i += sizeof(tceu_queue) + qu->sz;
        }
        CEU_ISR_ON();
    }

    /* remove broken links */
    {
        tceu_lnk* cur = CEU_LNKS;
        while (cur != NULL) {
            tceu_lnk* nxt = cur->nxt;
            if (!cur->src_app->isAlive || !cur->dst_app->isAlive)
                _ceu_sys_unlink(cur);
            cur = nxt;
        }
    }

    /* remove dead apps */
    tceu_app* app = CEU_APPS;
    tceu_app* prv = NULL;
    while (app)
    {
        tceu_app* nxt = app->nxt;

        if (app->isAlive) {
            prv = app;

        } else {
            if (CEU_APPS == app) {
                CEU_APPS = nxt;     /* remove as head */
            } else {
                prv->nxt = nxt;     /* remove in the middle */
            }

            /* unlink all "from app" or "to app" */
            ceu_sys_unlink(app,0, 0,0);
            ceu_sys_unlink(0,0, app,0);

#ifdef CEU_RET
            ok--;
            ret += app->ret;
#endif

            /* free app memory */
            ceu_sys_free(app->data);
            ceu_sys_free(app);
        }

        app = nxt;
    }
}

#ifdef CEU_ISR

typedef struct {
    tceu_isr_f f;
    tceu_app*  app;
} tceu_isr;

#define CEU_ISR_MAX 40
tceu_isr CEU_ISR_VEC[CEU_ISR_MAX];

int ceu_sys_isr (int n, tceu_isr_f f, tceu_app* app) {
    tceu_isr* isr = &CEU_ISR_VEC[(n-1)];
    if (f==NULL || isr->f==NULL) {
        isr->f   = ((word)app->addr>>1) + f;
        isr->app = app;
                           /* "f" is relative to "app", make it absolute */
        return 1;
    } else {
        return 0;
    }
}
#endif

void ceu_os_init (void) {
#ifdef CEU_ISR
    int i;
    for (i=0; i<CEU_ISR_MAX; i++) {
        CEU_ISR_VEC[i].f = NULL;      /* TODO: is this required? (bss=0) */
    }
    CEU_ISR_ON();       /* enable global interrupts to start */
#endif
}

int ceu_os_scheduler (int(*dt)())
{
    /*
     * Intercalate DT->WCLOCK->ASYNC->QUEUE->...
     * QUEUE last to separate app->init() from OS_START.
     * QUEUE handles one event at a time to intercalate with WCLOCK.
     * __ceu_os_gc() only if QUEUE is emtpy: has to keep data from events 
     * accessible.
     */

#ifdef CEU_RET
    while (ok > 0)
#else
    while (1)
#endif
    {
#if defined(CEU_WCLOCKS) || defined(CEU_IN_OS_DT)
        s32 _dt = dt();
#endif

        /* DT */
#ifdef CEU_IN_OS_DT
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN_OS_DT, CEU_EVTP(_dt));
                app = app->nxt;
            }
        }
#endif	/* CEU_IN_OS_DT */

        /* WCLOCK */
#ifdef CEU_WCLOCKS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
/*
#error TODO: CEU_IN__WCLOCK_
*/
                ceu_sys_go(app, CEU_IN__WCLOCK, CEU_EVTP(_dt));
                app = app->nxt;
            }
        }
#endif	/* CEU_WCLOCKS */

        /* ASYNC */
#ifdef CEU_ASYNCS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN__ASYNC, CEU_EVTP((void*)NULL));
                app = app->nxt;
            }
        }
#endif	/* CEU_ASYNCS */

        /* EVENTS */
        {
            /* clear the current size (ignore events emitted here) */
            CEU_ISR_OFF();
            int tot = QUEUE_tot;
            CEU_ISR_ON();
            if (tot > 0)
            {
                tceu_queue* qu = ceu_sys_queue_get();
                tot -= sizeof(tceu_queue) + qu->sz;
                if (qu->evt == CEU_IN__NONE) {
                    /* nothing; */
                    /* "fill event" */

                /* global events (e.g. OS_START, OS_INTERRUPT) */
                } else if (qu->app == NULL) {
                    tceu_app* app = CEU_APPS;
                    while (app) {
                        ceu_sys_go(app, qu->evt, qu->param);
                        app = app->nxt;
                    }

                } else {
                    /* linked events */
                    tceu_lnk* lnk = CEU_LNKS;
                    while (lnk) {
                        if ( qu->app==lnk->src_app
                        &&   qu->evt==lnk->src_evt
                        &&   lnk->dst_app->isAlive ) {
                            ceu_sys_go(lnk->dst_app, lnk->dst_evt, qu->param);
                        }
                        lnk = lnk->nxt;
                    }
                }

                ceu_sys_queue_rem();
            }
            else
            {
                __ceu_os_gc();     /* only when queue is empty */
            }
        }
    }

#ifdef CEU_RET
    return ret;
#else
    return 0;
#endif
}

/* LOAD / START */

tceu_app* ceu_sys_load (void* addr)
{
    uint       size;
    tceu_init* init;

#ifdef __AVR
    ((tceu_export) ((word)addr>>1))(&size, &init);
#else
    ((tceu_export) addr)(&size, &init);
#endif

    tceu_app* app = (tceu_app*) ceu_sys_malloc(sizeof(tceu_app));
    if (app == NULL) {
        return NULL;
    }

    app->data = (tceu_org*) ceu_sys_malloc(size);
    if (app->data == NULL) {
        return NULL;
    }

    app->sys_vec = CEU_SYS_VEC;
    app->nxt = NULL;

    /* Assumes sizeof(void*)==sizeof(WORD) and
        that gcc will word-align SIZE/INIT */
#ifdef __AVR
    app->init = (tceu_init) (((word)addr>>1) + (word)init);
#else
    app->init = (tceu_init) ((word)init);
#endif
    app->addr = addr;

    return app;
}

void ceu_sys_start (tceu_app* app)
{
    /* add as head */
	if (CEU_APPS == NULL) {
		CEU_APPS = app;

    /* add to tail */
    } else {
		tceu_app* cur = CEU_APPS;
        while (cur->nxt != NULL)
            cur = cur->nxt;
        cur->nxt = app;
    }

    /* MAX OK */
#ifdef CEU_RET
    ok++;
#endif

    /* INIT */

/*
printf(">>> %p %X %p[%x %x %x %x %x]\n", addr, size, init,
        ((unsigned char*)init)[5],
        ((unsigned char*)init)[6],
        ((unsigned char*)init)[7],
        ((unsigned char*)init)[8],
        ((unsigned char*)init)[9]);
printf("<<< %d %d\n", app->isAlive, app->ret);
*/

    app->init(app);

/*
#define GPFSEL1 ((uint*)0x20200004)
#define GPSET0  ((uint*)0x2020001C)
#define GPCLR0  ((uint*)0x20200028)
uint ra;
ra = *GPFSEL1;
ra = ra & ~(7<<18);
ra = ra | 1<<18;
*GPFSEL1 = ra;
*GPCLR0 = 1<<16;   // GPIO16 on
// *GPSET0 = 1<<16;   // GPIO16 off
*/

    /* OS_START */

#ifdef CEU_IN_OS_START
    ceu_sys_emit(NULL, CEU_IN_OS_START, CEU_EVTP((void*)NULL), 0, NULL);
#endif
}

/* LINK & UNLINK */

int ceu_sys_link (tceu_app* src_app, tceu_nevt src_evt,
                  tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* lnk = (tceu_lnk*) ceu_sys_malloc(sizeof(tceu_lnk));
    if (lnk == NULL)
        return 0;

    lnk->src_app = src_app;
    lnk->src_evt = src_evt;
    lnk->dst_app = dst_app;
    lnk->dst_evt = dst_evt;
    lnk->nxt = NULL;

    /* add as head */
	if (CEU_LNKS == NULL) {
		CEU_LNKS = lnk;

    /* add to tail */
    } else {
		tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt != NULL)
            cur = cur->nxt;
		cur->nxt = lnk;
    }

    return 1;
}

int ceu_sys_unlink (tceu_app* src_app, tceu_nevt src_evt,
                    tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* cur = CEU_LNKS;
    while (cur != NULL) {
        tceu_lnk* nxt = cur->nxt;
        if ( (src_app==0 || src_app==cur->src_app)
          && (src_evt==0 || src_evt==cur->src_evt)
          && (dst_app==0 || dst_app==cur->dst_app)
          && (dst_evt==0 || dst_evt==cur->dst_evt) ) {
            _ceu_sys_unlink(cur);
        }
        cur = nxt;
    }
    return 0;
}

#ifdef CEU_ISR

/* Foreach ISR, call ceu_sys_emit(CEU_IN_OS_INTERRUPT). */

#define GEN_ISR(n)                                                  \
    ISR(__vector_ ## n, ISR_BLOCK) {                                \
        tceu_isr* isr = &CEU_ISR_VEC[n-1];                          \
        if (isr->f != NULL) {                                       \
            CEU_APP_ADDR = isr->app->addr;                          \
            isr->f(isr->app, isr->app->data);                       \
            CEU_APP_ADDR = 0;                                       \
        }                                                           \
        ceu_sys_emit(NULL,CEU_IN_OS_INTERRUPT,CEU_EVTP(n),0,NULL); \
    }
#define _GEN_ISR(n)

GEN_ISR(20);
/*
GEN_ISR( 1) GEN_ISR( 2) GEN_ISR( 3) GEN_ISR( 4) GEN_ISR( 5)
GEN_ISR( 6) GEN_ISR( 7) GEN_ISR( 8) GEN_ISR( 9) GEN_ISR(10)
GEN_ISR(11) GEN_ISR(12) GEN_ISR(13) GEN_ISR(14) GEN_ISR(15)
GEN_ISR(16) GEN_ISR(17) _GEN_ISR(18) GEN_ISR(19) GEN_ISR(20)
GEN_ISR(21) GEN_ISR(22) GEN_ISR(23) GEN_ISR(24) GEN_ISR(25)
GEN_ISR(26) GEN_ISR(27) GEN_ISR(28) GEN_ISR(29) GEN_ISR(30)
GEN_ISR(31) GEN_ISR(32) GEN_ISR(33) GEN_ISR(34) GEN_ISR(35)
GEN_ISR(36) GEN_ISR(37) GEN_ISR(38) GEN_ISR(39) GEN_ISR(40)
*/

#endif /* CEU_ISR */

#endif  /* CEU_OS */


#include <stdlib.h>
#ifdef CEU_DEBUG
#include <stdio.h>      /* fprintf */
#include <signal.h>     /* signal */
#endif
#ifdef CEU_RUNTESTS
#include <string.h>     /* memset */
#endif
#ifdef CEU_THREADS
#include <assert.h>
#endif

#ifdef CEU_THREADS
#   define CEU_ATOMIC(f)                                      \
            CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex); \
                f                                             \
            CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
#else
#   define CEU_ATOMIC(f) f
#endif

#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

typedef struct {
    int     size;
    int     free;
    int     index;
    int     unit;
    byte**  queue;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type* name##_queue[size];          \
    type  name##_mem[size];            \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit,
                    byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit,
                    byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

#ifdef CEU_IFCS
#include <stddef.h>
/* TODO: === direto? */
#define CEU_NCLS       (3)
#endif

/* native code from the Main class */


/* class definitions */
/* may use types defined above in "NATIVE" */
/* each class may define new native code that appear after its struct declaration */

typedef void CEU_Worker;



typedef struct CEU_ResourceManager {
  struct tceu_org org;
  tceu_trl trls_[ 4 ];
  struct { /* BLOCK ln=14 */
    #line 16 "hello.ceu"
CEU_Worker* a;
    #line 17 "hello.ceu"
CEU_Worker* b;
    union {
      struct { /* BLOCK ln=19 */
        #line 19 "hello.ceu"
Queue queue;
        #line 22 "hello.ceu"
bool a_idle;
        #line 23 "hello.ceu"
bool b_idle;
        union {
          union {
          };
          union {
          };
          union {
          };
          struct {
            struct { /* BLOCK ln=26 */
              #line 26 "hello.ceu"
int details_7;
              union {
                union {
                };
                  union {
                    union {
                    };
                    struct { /* BLOCK ln=28 */
                      union {
                          struct { /* BLOCK ln=29 */
                            union {
                              union {
                              };
                            };
                          };
                            struct { /* BLOCK ln=33 */
                              union {
                                union {
                                };
                              };
                            };
                            struct { /* BLOCK ln=37 */
                              union {
                              };
                            };
                      };
                    };
                  };
              };
            };
            struct { /* BLOCK ln=42 */
              union {
                  union {
                    struct { /* BLOCK ln=43 */
                      union {
                          struct { /* BLOCK ln=44 */
                            union {
                              union {
                              };
                            };
                          };
                          struct { /* BLOCK ln=47 */
                            union {
                            };
                          };
                      };
                    };
                  };
              };
            };
            struct { /* BLOCK ln=52 */
              union {
                  union {
                    struct { /* BLOCK ln=53 */
                      union {
                          struct { /* BLOCK ln=54 */
                            union {
                              union {
                              };
                            };
                          };
                          struct { /* BLOCK ln=57 */
                            union {
                            };
                          };
                      };
                    };
                  };
              };
            };
          };
        };
      };
    };
  };

} CEU_ResourceManager;



typedef struct CEU_MockWorker {
  struct tceu_org org;
  tceu_trl trls_[ 2 ];
  struct { /* BLOCK ln=64 */
    #line 66 "hello.ceu"
int id;
    union {
      struct { /* BLOCK ln=68 */
        #line 68 "hello.ceu"
int details;
        union {
          union {
          };
            union {
              union {
              };
              struct { /* BLOCK ln=70 */
                #line 71 "hello.ceu"
int reply_to_5;
                union {
                  union {
                  };
                    union {
                      union {
                      };
                      struct { /* BLOCK ln=73 */
                        union {
                            struct { /* BLOCK ln=74 */
                              union {
                              };
                            };
                        };
                      };
                    };
                };
              };
            };
        };
      };
    };
  };

} CEU_MockWorker;


typedef struct CEU_Main {
  struct tceu_org org;
  tceu_trl trls_[ 5 ];
  struct { /* BLOCK ln=1 */
    union {
      struct { /* BLOCK ln=1 */
        union {
            struct { /* BLOCK ln=1 */
              #line 82 "hello.ceu"
CEU_MockWorker one;
            tceu_org_lnk __lnks_265_1[2];
              #line 85 "hello.ceu"
CEU_MockWorker two;
            tceu_org_lnk __lnks_265_2[2];
              #line 88 "hello.ceu"
CEU_ResourceManager r;
            tceu_org_lnk __lnks_265_3[2];
              #line 93 "hello.ceu"
int details;
              union {
                union {
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                  union {
                  };
                      struct { /* BLOCK ln=83 */
                        union {
                        };
                      };
                      struct { /* BLOCK ln=86 */
                        union {
                        };
                      };
                      struct { /* BLOCK ln=89 */
                        union {
                        };
                      };
                  union {
                  };
                    union {
                      union {
                      };
                      struct { /* BLOCK ln=95 */
                        union {
                          union {
                          };
                        };
                      };
                    };
                };
              };
            };
        };
      };
    };
  };

} CEU_Main;




/* goto labels */
enum {
    ResourceManager_ParEver_sub_2_0 = 0,
    ResourceManager_ParEver_sub_3_1 = 1,
    ResourceManager_ParEver_out_2 = 2,
    ResourceManager_Awake_go_task_3 = 3,
    ResourceManager_EmitInt_cont_4 = 4,
    ResourceManager_EmitInt_cont_5 = 5,
    ResourceManager_Awake_ok_done_6 = 6,
    ResourceManager_EmitInt_cont_7 = 7,
    ResourceManager_Awake_ok_done_8 = 8,
    ResourceManager_EmitInt_cont_9 = 9,
    Class_ResourceManager = 10,
    ResourceManager_Class_free_ResourceManager_11 = 11,
    MockWorker_Awake_go_task_12 = 12,
    MockWorker_Awake_REMOTE_WORKER_DONE_13 = 13,
    MockWorker_EmitInt_cont_14 = 14,
    Class_MockWorker = 15,
    MockWorker_Class_free_MockWorker_16 = 16,
    Main_Set_out_17 = 17,
    Main_Start_cnt_18 = 18,
    Main_Start_cnt_19 = 19,
    Main_Start_cnt_20 = 20,
    Main_Awake_USER_TASK_21 = 21,
    Main_EmitInt_cont_22 = 22,
    Main_Clear_23 = 23,
    Class_Main = 24,
    Main_Class_free_Main_25 = 25,

};

typedef struct {
#ifdef CEU_IFCS
#ifdef CEU_OS
#error remove from RAM!
#endif
    s8        ifcs_clss[CEU_NCLS][1];
            /* Does "cls" implements "ifc?"
             * (I*) ifc = (I*) cls;     // returns null if not
             * TODO(ram): bitfield
             */

    u16       ifcs_flds[CEU_NCLS][0];
    u16       ifcs_evts[CEU_NCLS][6];
    void*     ifcs_funs[CEU_NCLS][0];
    tceu_ntrl ifcs_trls[CEU_NCLS][0];
#endif
} _tceu_app;

/* TODO: remove from RAM */
static _tceu_app _CEU_APP = {
#ifdef CEU_IFCS
#ifdef CEU_OS
#error remove from RAM!
#endif
    {
		{0},
		{1},
		{0}
    },
    {
		{},
		{},
		{}
    },
    {
		{0,0,0,1,2,0},
		{0,0,0,1,2,3},
		{0,0,0,1,0,0}
    },
    {
		{},
		{},
		{}
    },
    {
		{},
		{},
		{}
    }
#endif
};

/**********************************************************************/

#ifndef CEU_OS
#ifdef CEU_DEBUG
tceu_app* CEU_APP_SIG = NULL;
static void ceu_segfault (int sig_num) {
#ifdef CEU_ORGS
    fprintf(stderr, "SEGFAULT on %p : %d\n", CEU_APP_SIG->lst.org, CEU_APP_SIG->lst.lbl);
#else
    fprintf(stderr, "SEGFAULT on %d\n", CEU_APP_SIG->lst.lbl);
#endif
    exit(0);
}
#endif
#endif

#ifdef CEU_RUNTESTS
static void ceu_stack_clr () {
    int a[1000];
    memset(a, 0, sizeof(a));
}
#endif

/**********************************************************************/

#ifdef CEU_ORGS

#endif

#ifdef CEU_ORGS
static void _ceu_constr_226 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 226 */
/* NODE: Block 225 */

#line 83 "hello.ceu"
    {/* NODE: Stmts 224 */

#line 83 "hello.ceu"
    {/* NODE: SetExp 383 */

#line 83 "hello.ceu"
/* SET: . */
#line 83 "hello.ceu"
    ((CEU_MockWorker*)__ceu_org)->id = 1;
#line 83 "hello.ceu"
    }
#line 83 "hello.ceu"
/* CLEAR: Block (83) */
#line 83 "hello.ceu"
    }
#line 83 "hello.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 4 ]; */
}
static void _ceu_constr_235 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 235 */
/* NODE: Block 234 */

#line 86 "hello.ceu"
    {/* NODE: Stmts 233 */

#line 86 "hello.ceu"
    {/* NODE: SetExp 384 */

#line 86 "hello.ceu"
/* SET: . */
#line 86 "hello.ceu"
    ((CEU_MockWorker*)__ceu_org)->id = 2;
#line 86 "hello.ceu"
    }
#line 86 "hello.ceu"
/* CLEAR: Block (86) */
#line 86 "hello.ceu"
    }
#line 86 "hello.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 4 ]; */
}
static void _ceu_constr_248 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 248 */
/* NODE: Block 247 */

#line 89 "hello.ceu"
    {/* NODE: Stmts 246 */

#line 89 "hello.ceu"
    {/* NODE: SetExp 385 */

#line 89 "hello.ceu"
/* SET: . */
#line 89 "hello.ceu"
    ((CEU_ResourceManager*)__ceu_org)->a = (&((CEU_Main*)_ceu_go->org)->one);/* NODE: SetExp 386 */

#line 90 "hello.ceu"
/* SET: . */
#line 90 "hello.ceu"
    ((CEU_ResourceManager*)__ceu_org)->b = (&((CEU_Main*)_ceu_go->org)->two);
#line 89 "hello.ceu"
    }
#line 89 "hello.ceu"
/* CLEAR: Block (89) */
#line 89 "hello.ceu"
    }
#line 89 "hello.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 4 ]; */
}

#endif

#ifdef CEU_THREADS
/* THREADS_C */

#endif

/* FUNCTIONS_C */


#ifdef CEU_OS
static tceu_evtp ceu_app_calls (tceu_app* _ceu_app, tceu_nevt evt, tceu_evtp param) {
    switch (evt) {
        /* STUBS */
        
        /*
        case CEU_IN_XXX:
            return CEU_Main_XXX(param);
        */
        default:;
#ifdef CEU_DEBUG
#ifndef CEU_OS
            fprintf(stderr, "invalid call %d\n", evt);
#endif
#endif
    }
    return CEU_EVTP((void*)NULL);
}
#endif

static int ceu_app_go (tceu_app* _ceu_app, tceu_go* _ceu_go)
{
#ifdef CEU_GOTO
_CEU_GOTO_:
#endif

#ifdef CEU_DEBUG
#ifndef CEU_OS
#ifdef CEU_ORGS
    _ceu_app->lst.org = _ceu_go->org;
#endif
    _ceu_app->lst.trl = _ceu_go->trl;
    _ceu_app->lst.lbl = _ceu_go->lbl;
#endif
#ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "TRK: o.%p / l.%d\n", _ceu_go->org, _ceu_go->lbl);
#endif
#endif
#endif

#ifdef CEU_RUNTESTS
    ceu_stack_clr();
#endif

    switch (_ceu_go->lbl) {
        /* NODE: Root 413 */
/* NODE: Dcl_cls 0 */

#line 14 "hello.ceu"
case Class_ResourceManager:;
#line 14 "hello.ceu"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 0;
#endif
/* NODE: Block 353 */

#line 14 "hello.ceu"
    {/* NODE: Stmts 352 */

#line 14 "hello.ceu"
    {/* NODE: Block 183 */

#line 19 "hello.ceu"
    {/* NODE: Stmts 182 */

#line 19 "hello.ceu"
    {/* NODE: Stmts 312 */

#line 19 "hello.ceu"
    {/* NODE: Dcl_var 311 */

#line 19 "hello.ceu"
    }/* NODE: CallStmt 75 */

#line 20 "hello.ceu"
    init((&((CEU_ResourceManager*)_ceu_go->org)->queue));/* NODE: Stmts 316 */

#line 22 "hello.ceu"
    {/* NODE: Dcl_var 313 */
/* NODE: SetExp 317 */

#line 22 "hello.ceu"
/* SET: a_idle */
#line 22 "hello.ceu"
    ((CEU_ResourceManager*)_ceu_go->org)->a_idle = 1;
#line 22 "hello.ceu"
    }/* NODE: Stmts 321 */

#line 23 "hello.ceu"
    {/* NODE: Dcl_var 318 */
/* NODE: SetExp 322 */

#line 23 "hello.ceu"
/* SET: b_idle */
#line 23 "hello.ceu"
    ((CEU_ResourceManager*)_ceu_go->org)->b_idle = 1;
#line 23 "hello.ceu"
    }/* NODE: ParEver 181 */

#line 25 "hello.ceu"
/* ParEver: spawn subs */
#line 25 "hello.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 1 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = ResourceManager_ParEver_sub_2_0;
    trl->stk = _ceu_go->stki;
}

#line 25 "hello.ceu"
    /* TODO: function? */
{
    tceu_trl* trl = &_ceu_go->org->trls[ 2 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = ResourceManager_ParEver_sub_3_1;
    trl->stk = _ceu_go->stki;
}
/* NODE: Block 118 */

#line 26 "hello.ceu"
    {/* NODE: Stmts 117 */

#line 26 "hello.ceu"
    {/* NODE: Stmts 324 */

#line 26 "hello.ceu"
    {/* NODE: Dcl_var 323 */

#line 26 "hello.ceu"
    }/* NODE: Loop 328 */

#line 27 "hello.ceu"
    for (;;) {
/* NODE: Stmts 327 */

#line 27 "hello.ceu"
    {/* NODE: Stmts 329 */

#line 27 "hello.ceu"
    {/* NODE: AwaitInt 325 */

#line 27 "hello.ceu"
    _CEU_NO_325_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = ResourceManager_Awake_go_task_3;

#line 27 "hello.ceu"
    	return RET_HALT;
#line 27 "hello.ceu"
    case ResourceManager_Awake_go_task_3:;

#line 27 "hello.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)((CEU_ResourceManager*)_ceu_go->org) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_325_;
    }
#endif

#line 27 "hello.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: SetExp 331 */

#line 27 "hello.ceu"
/* SET: details */
#line 27 "hello.ceu"
    ((CEU_ResourceManager*)_ceu_go->org)->details_7 = (_ceu_go->evtp.v);
#line 27 "hello.ceu"
    }/* NODE: Block 115 */

#line 28 "hello.ceu"
    {/* NODE: Stmts 114 */

#line 28 "hello.ceu"
    {/* NODE: If 333 */

#line 28 "hello.ceu"
    if (((CEU_ResourceManager*)_ceu_go->org)->a_idle) {
/* NODE: Block 97 */

#line 29 "hello.ceu"
    {/* NODE: Stmts 96 */

#line 29 "hello.ceu"
    {/* NODE: CallStmt 88 */

#line 29 "hello.ceu"
    printf("ResourceManager delegates to A\n");/* NODE: Stmts 335 */

#line 30 "hello.ceu"
    {/* NODE: EmitNoTmp 334 */
/* NODE: EmitInt 92 */

#line 30 "hello.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = ResourceManager_EmitInt_cont_4;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = (_CEU_APP.ifcs_evts[((tceu_org*)((CEU_ResourceManager*)_ceu_go->org)->a)->cls][4]);
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_ResourceManager*)_ceu_go->org)->a;
#endif

#line 30 "hello.ceu"
    _ceu_go->evtp.v = ((CEU_ResourceManager*)_ceu_go->org)->details_7;

#line 30 "hello.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case ResourceManager_EmitInt_cont_4:;

#line 30 "hello.ceu"
    }/* NODE: SetExp 336 */

#line 31 "hello.ceu"
/* SET: a_idle */
#line 31 "hello.ceu"
    ((CEU_ResourceManager*)_ceu_go->org)->a_idle = 0;
#line 29 "hello.ceu"
    }
#line 29 "hello.ceu"
/* CLEAR: Block (29) */
#line 29 "hello.ceu"
    }
#line 29 "hello.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */
} else {
/* NODE: If 332 */

#line 28 "hello.ceu"
    if (((CEU_ResourceManager*)_ceu_go->org)->b_idle) {
/* NODE: Block 108 */

#line 33 "hello.ceu"
    {/* NODE: Stmts 107 */

#line 33 "hello.ceu"
    {/* NODE: CallStmt 99 */

#line 33 "hello.ceu"
    printf("ResourceManager delegates to B\n");/* NODE: Stmts 338 */

#line 34 "hello.ceu"
    {/* NODE: EmitNoTmp 337 */
/* NODE: EmitInt 103 */

#line 34 "hello.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = ResourceManager_EmitInt_cont_5;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = (_CEU_APP.ifcs_evts[((tceu_org*)((CEU_ResourceManager*)_ceu_go->org)->b)->cls][4]);
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_ResourceManager*)_ceu_go->org)->b;
#endif

#line 34 "hello.ceu"
    _ceu_go->evtp.v = ((CEU_ResourceManager*)_ceu_go->org)->details_7;

#line 34 "hello.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case ResourceManager_EmitInt_cont_5:;

#line 34 "hello.ceu"
    }/* NODE: SetExp 339 */

#line 35 "hello.ceu"
/* SET: b_idle */
#line 35 "hello.ceu"
    ((CEU_ResourceManager*)_ceu_go->org)->b_idle = 0;
#line 33 "hello.ceu"
    }
#line 33 "hello.ceu"
/* CLEAR: Block (33) */
#line 33 "hello.ceu"
    }
#line 33 "hello.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */
} else {
/* NODE: Block 112 */

#line 37 "hello.ceu"
    {/* NODE: Stmts 111 */

#line 37 "hello.ceu"
    {/* NODE: CallStmt 109 */

#line 37 "hello.ceu"
    printf("All workers are unavailable, so ResourceManager stores the task in a queue\n");/* NODE: CallStmt 110 */

#line 38 "hello.ceu"
    push((&((CEU_ResourceManager*)_ceu_go->org)->queue),((CEU_ResourceManager*)_ceu_go->org)->details_7);
#line 37 "hello.ceu"
    }
#line 37 "hello.ceu"
/* CLEAR: Block (37) */
#line 37 "hello.ceu"
    }
#line 37 "hello.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */
}
}

#line 28 "hello.ceu"
    }
#line 28 "hello.ceu"
/* CLEAR: Block (28) */
#line 28 "hello.ceu"
    }
#line 28 "hello.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 27 "hello.ceu"
    }
#line 27 "hello.ceu"
    }

#line 26 "hello.ceu"
    }
#line 26 "hello.ceu"
/* CLEAR: Block (26) */
#line 26 "hello.ceu"
    }
#line 25 "hello.ceu"
case ResourceManager_ParEver_sub_2_0:;/* NODE: Block 149 */

#line 42 "hello.ceu"
    {/* NODE: Stmts 148 */

#line 42 "hello.ceu"
    {/* NODE: Loop 342 */

#line 42 "hello.ceu"
    for (;;) {
/* NODE: Stmts 341 */

#line 42 "hello.ceu"
    {/* NODE: AwaitInt 340 */

#line 42 "hello.ceu"
    _CEU_NO_340_:
    _ceu_go->trl->evt = (_CEU_APP.ifcs_evts[((tceu_org*)((CEU_ResourceManager*)_ceu_go->org)->a)->cls][5]);
    _ceu_go->trl->lbl = ResourceManager_Awake_ok_done_6;

#line 42 "hello.ceu"
    	return RET_HALT;
#line 42 "hello.ceu"
    case ResourceManager_Awake_ok_done_6:;

#line 42 "hello.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)((CEU_ResourceManager*)_ceu_go->org)->a != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_340_;
    }
#endif

#line 42 "hello.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Block 146 */

#line 43 "hello.ceu"
    {/* NODE: Stmts 145 */

#line 43 "hello.ceu"
    {/* NODE: If 144 */

#line 43 "hello.ceu"
    if ((!empty((&((CEU_ResourceManager*)_ceu_go->org)->queue)))) {
/* NODE: Block 137 */

#line 44 "hello.ceu"
    {/* NODE: Stmts 136 */

#line 44 "hello.ceu"
    {/* NODE: CallStmt 127 */

#line 44 "hello.ceu"
    printf("ResourceManager sees A is done and queue is nonempty, starting A working on something\n");/* NODE: Stmts 344 */

#line 45 "hello.ceu"
    {/* NODE: EmitNoTmp 343 */
/* NODE: EmitInt 135 */

#line 45 "hello.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = ResourceManager_EmitInt_cont_7;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = (_CEU_APP.ifcs_evts[((tceu_org*)((CEU_ResourceManager*)_ceu_go->org)->a)->cls][4]);
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_ResourceManager*)_ceu_go->org)->a;
#endif

#line 45 "hello.ceu"
    _ceu_go->evtp.ptr = pop((&((CEU_ResourceManager*)_ceu_go->org)->queue));

#line 45 "hello.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case ResourceManager_EmitInt_cont_7:;

#line 45 "hello.ceu"
    }
#line 44 "hello.ceu"
    }
#line 44 "hello.ceu"
/* CLEAR: Block (44) */
#line 44 "hello.ceu"
    }
#line 44 "hello.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 1 ]; */
} else {
/* NODE: Block 143 */

#line 47 "hello.ceu"
    {/* NODE: Stmts 142 */

#line 47 "hello.ceu"
    {/* NODE: CallStmt 138 */

#line 47 "hello.ceu"
    printf("ResourceManager sees A is done and queue is empty, so A is now idle\n");/* NODE: SetExp 345 */

#line 48 "hello.ceu"
/* SET: a_idle */
#line 48 "hello.ceu"
    ((CEU_ResourceManager*)_ceu_go->org)->a_idle = 1;
#line 47 "hello.ceu"
    }
#line 47 "hello.ceu"
/* CLEAR: Block (47) */
#line 47 "hello.ceu"
    }
#line 47 "hello.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 1 ]; */
}

#line 43 "hello.ceu"
    }
#line 43 "hello.ceu"
/* CLEAR: Block (43) */
#line 43 "hello.ceu"
    }
#line 43 "hello.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 1 ]; */

#line 42 "hello.ceu"
    }
#line 42 "hello.ceu"
    }

#line 42 "hello.ceu"
    }
#line 42 "hello.ceu"
/* CLEAR: Block (42) */
#line 42 "hello.ceu"
    }
#line 25 "hello.ceu"
case ResourceManager_ParEver_sub_3_1:;/* NODE: Block 180 */

#line 52 "hello.ceu"
    {/* NODE: Stmts 179 */

#line 52 "hello.ceu"
    {/* NODE: Loop 348 */

#line 52 "hello.ceu"
    for (;;) {
/* NODE: Stmts 347 */

#line 52 "hello.ceu"
    {/* NODE: AwaitInt 346 */

#line 52 "hello.ceu"
    _CEU_NO_346_:
    _ceu_go->trl->evt = (_CEU_APP.ifcs_evts[((tceu_org*)((CEU_ResourceManager*)_ceu_go->org)->b)->cls][5]);
    _ceu_go->trl->lbl = ResourceManager_Awake_ok_done_8;

#line 52 "hello.ceu"
    	return RET_HALT;
#line 52 "hello.ceu"
    case ResourceManager_Awake_ok_done_8:;

#line 52 "hello.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)((CEU_ResourceManager*)_ceu_go->org)->b != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_346_;
    }
#endif

#line 52 "hello.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: Block 177 */

#line 53 "hello.ceu"
    {/* NODE: Stmts 176 */

#line 53 "hello.ceu"
    {/* NODE: If 175 */

#line 53 "hello.ceu"
    if ((!empty((&((CEU_ResourceManager*)_ceu_go->org)->queue)))) {
/* NODE: Block 168 */

#line 54 "hello.ceu"
    {/* NODE: Stmts 167 */

#line 54 "hello.ceu"
    {/* NODE: CallStmt 158 */

#line 54 "hello.ceu"
    printf("ResourceManager sees B is done and queue is nonempty, starting B working on something\n");/* NODE: Stmts 350 */

#line 55 "hello.ceu"
    {/* NODE: EmitNoTmp 349 */
/* NODE: EmitInt 166 */

#line 55 "hello.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = ResourceManager_EmitInt_cont_9;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = (_CEU_APP.ifcs_evts[((tceu_org*)((CEU_ResourceManager*)_ceu_go->org)->b)->cls][4]);
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_ResourceManager*)_ceu_go->org)->b;
#endif

#line 55 "hello.ceu"
    _ceu_go->evtp.ptr = pop((&((CEU_ResourceManager*)_ceu_go->org)->queue));

#line 55 "hello.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case ResourceManager_EmitInt_cont_9:;

#line 55 "hello.ceu"
    }
#line 54 "hello.ceu"
    }
#line 54 "hello.ceu"
/* CLEAR: Block (54) */
#line 54 "hello.ceu"
    }
#line 54 "hello.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */
} else {
/* NODE: Block 174 */

#line 57 "hello.ceu"
    {/* NODE: Stmts 173 */

#line 57 "hello.ceu"
    {/* NODE: CallStmt 169 */

#line 57 "hello.ceu"
    printf("ResourceManager sees B is done and queue is empty, so B is now idle\n");/* NODE: SetExp 351 */

#line 58 "hello.ceu"
/* SET: b_idle */
#line 58 "hello.ceu"
    ((CEU_ResourceManager*)_ceu_go->org)->b_idle = 1;
#line 57 "hello.ceu"
    }
#line 57 "hello.ceu"
/* CLEAR: Block (57) */
#line 57 "hello.ceu"
    }
#line 57 "hello.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */
}

#line 53 "hello.ceu"
    }
#line 53 "hello.ceu"
/* CLEAR: Block (53) */
#line 53 "hello.ceu"
    }
#line 53 "hello.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 2 ]; */

#line 52 "hello.ceu"
    }
#line 52 "hello.ceu"
    }

#line 52 "hello.ceu"
    }
#line 52 "hello.ceu"
/* CLEAR: Block (52) */
#line 52 "hello.ceu"
    }
#line 19 "hello.ceu"
    }
#line 19 "hello.ceu"
/* CLEAR: Block (19) */
#line 19 "hello.ceu"
    }
#line 14 "hello.ceu"
    }
#line 14 "hello.ceu"
/* CLEAR: Block (14) */
#line 14 "hello.ceu"
    }/* NODE: Dcl_cls 1 */

#line 64 "hello.ceu"
case Class_MockWorker:;
#line 64 "hello.ceu"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 1;
#endif
/* NODE: Block 380 */

#line 64 "hello.ceu"
    {/* NODE: Stmts 379 */

#line 64 "hello.ceu"
    {/* NODE: Block 217 */

#line 68 "hello.ceu"
    {/* NODE: Stmts 216 */

#line 68 "hello.ceu"
    {/* NODE: Stmts 360 */

#line 68 "hello.ceu"
    {/* NODE: Dcl_var 359 */

#line 68 "hello.ceu"
    }/* NODE: Loop 364 */

#line 69 "hello.ceu"
    for (;;) {
/* NODE: Stmts 363 */

#line 69 "hello.ceu"
    {/* NODE: Stmts 365 */

#line 69 "hello.ceu"
    {/* NODE: AwaitInt 361 */

#line 69 "hello.ceu"
    _CEU_NO_361_:
    _ceu_go->trl->evt = 2;
    _ceu_go->trl->lbl = MockWorker_Awake_go_task_12;

#line 69 "hello.ceu"
    	return RET_HALT;
#line 69 "hello.ceu"
    case MockWorker_Awake_go_task_12:;

#line 69 "hello.ceu"
    #ifdef CEU_ORGS
    if ((tceu_org*)((CEU_MockWorker*)_ceu_go->org) != _ceu_go->evto) {
        _ceu_go->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto _CEU_NO_361_;
    }
#endif

#line 69 "hello.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: SetExp 367 */

#line 69 "hello.ceu"
/* SET: details */
#line 69 "hello.ceu"
    ((CEU_MockWorker*)_ceu_go->org)->details = (_ceu_go->evtp.v);
#line 69 "hello.ceu"
    }/* NODE: Block 214 */

#line 70 "hello.ceu"
    {/* NODE: Stmts 213 */

#line 70 "hello.ceu"
    {/* NODE: CallStmt 194 */

#line 70 "hello.ceu"
    printf("MockWorker #%d starts a remote task working on %d\n",((CEU_MockWorker*)_ceu_go->org)->id,((CEU_MockWorker*)_ceu_go->org)->details);/* NODE: Stmts 369 */

#line 71 "hello.ceu"
    {/* NODE: Dcl_var 368 */

#line 71 "hello.ceu"
    }/* NODE: Loop 373 */

#line 72 "hello.ceu"
    for (;;) {
/* NODE: Stmts 372 */

#line 72 "hello.ceu"
    {/* NODE: Stmts 374 */

#line 72 "hello.ceu"
    {/* NODE: AwaitExt 370 */

#line 72 "hello.ceu"
        _ceu_go->trl->evt = CEU_IN_REMOTE_WORKER_DONE;
    _ceu_go->trl->lbl = MockWorker_Awake_REMOTE_WORKER_DONE_13;

#line 72 "hello.ceu"
    	return RET_HALT;
#line 72 "hello.ceu"
    case MockWorker_Awake_REMOTE_WORKER_DONE_13:;

#line 72 "hello.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: SetExp 376 */

#line 72 "hello.ceu"
/* SET: reply_to */
#line 72 "hello.ceu"
    ((CEU_MockWorker*)_ceu_go->org)->reply_to_5 = (_ceu_go->evtp.v);
#line 72 "hello.ceu"
    }/* NODE: Block 207 */

#line 73 "hello.ceu"
    {/* NODE: Stmts 206 */

#line 73 "hello.ceu"
    {/* NODE: If 378 */

#line 73 "hello.ceu"
    if ((((CEU_MockWorker*)_ceu_go->org)->reply_to_5==((CEU_MockWorker*)_ceu_go->org)->id)) {
/* NODE: Block 204 */

#line 74 "hello.ceu"
    {/* NODE: Stmts 203 */

#line 74 "hello.ceu"
    {/* NODE: Break 202 */

#line 74 "hello.ceu"
    break;
#line 74 "hello.ceu"
    }
#line 74 "hello.ceu"
/* CLEAR: Block (74) */
#line 74 "hello.ceu"
    }} else {
/* NODE: Nothing 377 */
}

#line 73 "hello.ceu"
    }
#line 73 "hello.ceu"
/* CLEAR: Block (73) */
#line 73 "hello.ceu"
    }
#line 73 "hello.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 72 "hello.ceu"
    }
#line 72 "hello.ceu"
    }

#line 72 "hello.ceu"
/* CLEAR: Loop (72) */
#line 72 "hello.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_go->trl = &_ceu_go->org->trls[ 0 ];
/* NODE: CallStmt 209 */

#line 77 "hello.ceu"
    printf("MockWorker #%d done with task, looking for new task\n",((CEU_MockWorker*)_ceu_go->org)->id);/* NODE: EmitInt 212 */

#line 78 "hello.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = MockWorker_EmitInt_cont_14;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = 3;
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) ((CEU_MockWorker*)_ceu_go->org);
#endif

#line 78 "hello.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case MockWorker_EmitInt_cont_14:;

#line 70 "hello.ceu"
    }
#line 70 "hello.ceu"
/* CLEAR: Block (70) */
#line 70 "hello.ceu"
    }
#line 70 "hello.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 0 ]; */

#line 69 "hello.ceu"
    }
#line 69 "hello.ceu"
    }

#line 68 "hello.ceu"
    }
#line 68 "hello.ceu"
/* CLEAR: Block (68) */
#line 68 "hello.ceu"
    }
#line 64 "hello.ceu"
    }
#line 64 "hello.ceu"
/* CLEAR: Block (64) */
#line 64 "hello.ceu"
    }/* NODE: Dcl_cls 2 */

#line 1 "_ceu_cpp_hello.ceu.in"
case Class_Main:;
#line 1 "_ceu_cpp_hello.ceu.in"
    #ifdef CEU_IFCS
_ceu_go->org->cls = 2;
#endif
/* NODE: Block 399 */

#line 1 "_ceu_cpp_hello.ceu.in"
    {/* NODE: Stmts 398 */

#line 1 "_ceu_cpp_hello.ceu.in"
    {/* NODE: Nothing 277 */
/* NODE: Block 271 */

#line 1 "_ceu_cpp_hello.ceu.in"
    {
#line 1 "_ceu_cpp_hello.ceu.in"
    int __ceu__ret_0
#line 1 "_ceu_cpp_hello.ceu.in"
    ;/* NODE: Stmts 270 */

#line 1 "_ceu_cpp_hello.ceu.in"
    {/* NODE: Dcl_var 267 */
/* NODE: SetBlock 269 */
/* NODE: Block 265 */

#line 1 "_ceu_cpp_hello.ceu.in"
    {
#line 1 "_ceu_cpp_hello.ceu.in"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 1, (tceu_org_lnk*) &((CEU_Main*)_ceu_go->org)->__lnks_265_1);

#line 1 "_ceu_cpp_hello.ceu.in"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 2, (tceu_org_lnk*) &((CEU_Main*)_ceu_go->org)->__lnks_265_2);

#line 1 "_ceu_cpp_hello.ceu.in"
    /* TODO: CEU_OS */
ceu_out_org_trail(_ceu_go->org, 3, (tceu_org_lnk*) &((CEU_Main*)_ceu_go->org)->__lnks_265_3);

#line 1 "_ceu_cpp_hello.ceu.in"
    /* switch to blk trail */
_ceu_go->trl = &_ceu_go->org->trls[ 4 ];
/* NODE: Stmts 264 */

#line 1 "_ceu_cpp_hello.ceu.in"
    {/* NODE: Stmts 261 */

#line 1 "hello.ceu"
    {/* NODE: Stmts 282 */

#line 1 "hello.ceu"
    {/* NODE: Nothing 402 */

#line 1 "hello.ceu"
    }/* NODE: Stmts 284 */

#line 2 "hello.ceu"
    {/* NODE: Nothing 403 */

#line 2 "hello.ceu"
    }/* NODE: Stmts 286 */

#line 3 "hello.ceu"
    {/* NODE: Nothing 404 */

#line 3 "hello.ceu"
    }/* NODE: Stmts 288 */

#line 4 "hello.ceu"
    {/* NODE: Nothing 405 */

#line 4 "hello.ceu"
    }/* NODE: Stmts 290 */

#line 5 "hello.ceu"
    {/* NODE: Nothing 406 */

#line 5 "hello.ceu"
    }/* NODE: Stmts 292 */

#line 6 "hello.ceu"
    {/* NODE: Nothing 407 */

#line 6 "hello.ceu"
    }/* NODE: Stmts 294 */

#line 7 "hello.ceu"
    {/* NODE: Nothing 408 */

#line 7 "hello.ceu"
    }/* NODE: Nothing 409 */
/* NODE: Nothing 410 */
/* NODE: Nothing 411 */
/* NODE: Dcl_var 227 */

#line 82 "hello.ceu"
/* start org: one */
#line 82 "hello.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Main*)_ceu_go->org)->one)),2,Class_MockWorker,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 82 "hello.ceu"
            _ceu_constr_226(_ceu_app, ((tceu_org*) (&((CEU_Main*)_ceu_go->org)->one)), _ceu_go);

#line 82 "hello.ceu"
        }
}

#line 82 "hello.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Main_Start_cnt_18,((tceu_org*) (&((CEU_Main*)_ceu_go->org)->one)),Class_MockWorker);
case Main_Start_cnt_18:;
/* NODE: Dcl_var 236 */

#line 85 "hello.ceu"
/* start org: two */
#line 85 "hello.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Main*)_ceu_go->org)->two)),2,Class_MockWorker,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 2);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 85 "hello.ceu"
            _ceu_constr_235(_ceu_app, ((tceu_org*) (&((CEU_Main*)_ceu_go->org)->two)), _ceu_go);

#line 85 "hello.ceu"
        }
}

#line 85 "hello.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Main_Start_cnt_19,((tceu_org*) (&((CEU_Main*)_ceu_go->org)->two)),Class_MockWorker);
case Main_Start_cnt_19:;
/* NODE: Dcl_var 249 */

#line 88 "hello.ceu"
/* start org: r */
#line 88 "hello.ceu"
    /* each org has its own trail on enclosing block */
{
    int i;
    for (i=0; i<1; i++) {
        /* resets org memory and starts org.trail[0]=Class_XXX */
        ceu_out_org(_ceu_app, ((tceu_org*) (&((CEU_Main*)_ceu_go->org)->r)),4,Class_ResourceManager,
                _ceu_go->stki+1,    /* run now */
#ifdef CEU_NEWS
                0,
#endif
_ceu_go->org, 3);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 88 "hello.ceu"
            _ceu_constr_248(_ceu_app, ((tceu_org*) (&((CEU_Main*)_ceu_go->org)->r)), _ceu_go);

#line 88 "hello.ceu"
        }
}

#line 88 "hello.ceu"
    /* TODO: CEU_OS */
    return ceu_out_org_spawn(_ceu_go, Main_Start_cnt_20,((tceu_org*) (&((CEU_Main*)_ceu_go->org)->r)),Class_ResourceManager);
case Main_Start_cnt_20:;
/* NODE: Stmts 388 */

#line 93 "hello.ceu"
    {/* NODE: Dcl_var 387 */

#line 93 "hello.ceu"
    }/* NODE: Loop 392 */

#line 94 "hello.ceu"
    for (;;) {
/* NODE: Stmts 391 */

#line 94 "hello.ceu"
    {/* NODE: Stmts 393 */

#line 94 "hello.ceu"
    {/* NODE: AwaitExt 389 */

#line 94 "hello.ceu"
        _ceu_go->trl->evt = CEU_IN_USER_TASK;
    _ceu_go->trl->lbl = Main_Awake_USER_TASK_21;

#line 94 "hello.ceu"
    	return RET_HALT;
#line 94 "hello.ceu"
    case Main_Awake_USER_TASK_21:;

#line 94 "hello.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
fprintf(stderr, "\tOK!\n");
#endif
#endif
/* NODE: SetExp 395 */

#line 94 "hello.ceu"
/* SET: details */
#line 94 "hello.ceu"
    ((CEU_Main*)_ceu_go->org)->details = (_ceu_go->evtp.v);
#line 94 "hello.ceu"
    }/* NODE: Block 259 */

#line 95 "hello.ceu"
    {/* NODE: Stmts 258 */

#line 95 "hello.ceu"
    {/* NODE: Stmts 397 */

#line 95 "hello.ceu"
    {/* NODE: EmitNoTmp 396 */
/* NODE: EmitInt 257 */

#line 95 "hello.ceu"
    _ceu_go->stk[_ceu_go->stki].evtp = _ceu_go->evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_ceu_go->stk[_ceu_go->stki].evto = _ceu_go->evto;
#endif
#endif
_ceu_go->stk[_ceu_go->stki].evt  = _ceu_go->evt;    /* 3rd (stk) other trails */

_ceu_go->trl->evt = CEU_IN__STK;
_ceu_go->trl->stk = _ceu_go->stki++;                /* 2nd (stk) me */
_ceu_go->trl->lbl = Main_EmitInt_cont_22;
                                            /* 1st (stk+1) my lsts */
/* TRIGGER EVENT */
_ceu_go->evt  = 2;
#ifdef CEU_ORGS
_ceu_go->evto = (tceu_org*) (&((CEU_Main*)_ceu_go->org)->r);
#endif

#line 95 "hello.ceu"
    _ceu_go->evtp.v = ((CEU_Main*)_ceu_go->org)->details;

#line 95 "hello.ceu"
    #ifdef CEU_ORGS
_ceu_go->org = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
/*goto _CEU_CALL_ORG_;*/
return RET_ORG;

case Main_EmitInt_cont_22:;

#line 95 "hello.ceu"
    }
#line 95 "hello.ceu"
    }
#line 95 "hello.ceu"
/* CLEAR: Block (95) */
#line 95 "hello.ceu"
    }
#line 95 "hello.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_go->trl = &_ceu_go->org->trls[ 4 ]; */

#line 94 "hello.ceu"
    }
#line 94 "hello.ceu"
    }

#line 1 "hello.ceu"
    }
#line 1 "_ceu_cpp_hello.ceu.in"
    }
#line 1 "_ceu_cpp_hello.ceu.in"
/* CLEAR: Block (1) */
#line 1 "_ceu_cpp_hello.ceu.in"
    }
#line 1 "_ceu_cpp_hello.ceu.in"
    	return RET_HALT;
#line 1 "_ceu_cpp_hello.ceu.in"
case Main_Set_out_17:;
#line 1 "_ceu_cpp_hello.ceu.in"
    }
#line 1 "_ceu_cpp_hello.ceu.in"
/* CLEAR: Block (1) */
#line 1 "_ceu_cpp_hello.ceu.in"
    }
#line 1 "_ceu_cpp_hello.ceu.in"
    }
#line 1 "_ceu_cpp_hello.ceu.in"
/* CLEAR: Block (1) */
#line 1 "_ceu_cpp_hello.ceu.in"
    }
    }
    return RET_HALT;    /* TODO: should never be reached anyways */
}

static __attribute__((noinline))  __attribute__((noclone))
void
ceu_app_init (tceu_app* app)
{
    app->seqno = 0;
#if defined(CEU_RET) || defined(CEU_OS)
    app->isAlive = 1;
#endif
#ifdef CEU_ASYNCS
    app->pendingAsyncs = 1;
#endif
#ifdef CEU_RET
    app->ret = 0;
#endif
#ifdef CEU_WCLOCKS
    app->wclk_late = 0;
    app->wclk_min = CEU_WCLOCK_INACTIVE;
    app->wclk_min_tmp = CEU_WCLOCK_INACTIVE;
#ifdef CEU_TIMEMACHINE
    app->wclk_late_ = 0;
    app->wclk_min_ = CEU_WCLOCK_INACTIVE;
    app->wclk_min_tmp_ = CEU_WCLOCK_INACTIVE;
#endif
#endif
#ifdef CEU_THREADS
    pthread_mutex_init(&app->threads_mutex, NULL);
    /*PTHREAD_COND_INITIALIZER,*/
    app->threads_n = 0;

    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif
#ifdef CEU_LUA
    app->lua = luaL_newstate();
    /* TODO: lua_close(CEU_L); */
    assert(app->lua != NULL);
    luaL_openlibs(app->lua);
    lua_atpanic(app->lua, ceu_lua_atpanic);
#endif

#ifdef CEU_OS

#ifdef __AVR
    app->code  = (__typeof__(ceu_app_go)*)    (((word)app->addr>>1) + &ceu_app_go);
    app->calls = (__typeof__(ceu_app_calls)*) (((word)app->addr>>1) + &ceu_app_calls);
#else
    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);
    app->calls = (__typeof__(ceu_app_calls)*) (&ceu_app_calls);
#endif

#else   /* !CEU_OS */

    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);

#endif  /* CEU_OS */

#ifndef CEU_OS
#ifdef CEU_DEBUG
    CEU_APP_SIG = app;
    signal(SIGSEGV, ceu_segfault);
#endif
#endif

    ceu_out_org(app, app->data, CEU_NTRAILS, Class_Main, 0,
#ifdef CEU_NEWS
                0,
#endif
                NULL, 0);
    ceu_out_go(app, CEU_IN__INIT, CEU_EVTP((void*)NULL));
}

/* EXPORTED ENTRY POINT
 * CEU_EXPORT is put in a separate section ".export".
 * "gcc-ld" should place it at 0x00, before ".text".
 */

#ifdef CEU_OS
__attribute__ ((section (".export")))
void CEU_EXPORT (uint* size, tceu_init** init) {
    *size = sizeof(CEU_Main);
    *init = (tceu_init*) &ceu_app_init;
}
#endif
